{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"httpr","text":"<p> Blazing fast HTTP client for Python, built in Rust. </p> <p> </p> <p>httpr is a drop-in replacement for <code>httpx</code> and <code>requests</code> with significantly better performance. Built on top of Rust's <code>reqwest</code> library with zero Python dependencies.</p> <pre><code>import httpr\n\n# Simple as requests\nresponse = httpr.get(\"https://httpbin.org/get\")\nprint(response.json())\n\n# Or use a client for connection pooling\nwith httpr.Client() as client:\n    response = client.get(\"https://httpbin.org/get\")\n    print(response.status_code)  # 200\n</code></pre> <ul> <li> <p> Fast</p> <p>Built on Rust's <code>reqwest</code> - one of the fastest HTTP clients available. See the benchmarks.</p> </li> <li> <p> Sync &amp; Async</p> <p>Both synchronous <code>Client</code> and <code>AsyncClient</code> with identical APIs. First-class async support.</p> </li> <li> <p> Lightweight</p> <p>Zero Python dependencies. Everything is implemented in Rust. Just install and use.</p> </li> <li> <p> Secure</p> <p>Full SSL/TLS support including mTLS (mutual TLS) for enterprise authentication.</p> </li> <li> <p> HTTP/2</p> <p>Native HTTP/2 support for better performance with multiplexed connections.</p> </li> <li> <p> Cookie Store</p> <p>Automatic cookie handling with persistent cookie store across requests.</p> </li> </ul>"},{"location":"#installation","title":"Installation","text":"uv (recommended)pip <pre><code>uv add httpr\n</code></pre> <pre><code>pip install httpr\n</code></pre>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>import httpr\n\n# Create a client with default settings\nclient = httpr.Client(\n    timeout=30,\n    follow_redirects=True,\n)\n\n# Make requests\nresponse = client.get(\"https://httpbin.org/get\", params={\"key\": \"value\"})\nprint(response.status_code)  # 200\nprint(response.json())       # {\"args\": {\"key\": \"value\"}, ...}\n\n# POST with JSON\nresponse = client.post(\n    \"https://httpbin.org/post\",\n    json={\"name\": \"httpr\", \"fast\": True}\n)\n\n# Response properties\nprint(response.text)         # Response body as text\nprint(response.content)      # Response body as bytes\nprint(response.headers)      # Response headers (case-insensitive)\nprint(response.cookies)      # Response cookies\n</code></pre>"},{"location":"#features","title":"Features","text":"<ul> <li> <p> Streaming</p> <p>Stream large responses efficiently without buffering entire response in memory. Iterate bytes, text, or lines.</p> </li> </ul>"},{"location":"#not-yet-implemented","title":"Not Yet Implemented","text":"<ul> <li>Fine-grained error handling: Detailed error types are in development</li> </ul>"},{"location":"#llm-friendly-documentation","title":"LLM-Friendly Documentation","text":"<p>This documentation is available in LLM-optimized formats:</p> <ul> <li>llms.txt - Documentation index for LLMs</li> <li>llms-full.txt - Complete documentation in a single file</li> </ul> <ul> <li> <p> Learn</p> <p>New to httpr? Start with the Quickstart guide.</p> <p> Quickstart</p> </li> <li> <p> Tutorial</p> <p>Step-by-step guides covering all features.</p> <p> Tutorial</p> </li> <li> <p> Advanced</p> <p>SSL/TLS, proxies, cookies, and more.</p> <p> Advanced</p> </li> <li> <p> API Reference</p> <p>Complete API documentation.</p> <p> API Reference</p> </li> </ul>"},{"location":"quickstart/","title":"Quickstart","text":"<p>This guide will get you up and running with httpr in minutes.</p>"},{"location":"quickstart/#installation","title":"Installation","text":"uv (recommended)pip <pre><code>uv add httpr\n</code></pre> <pre><code>pip install httpr\n</code></pre>"},{"location":"quickstart/#your-first-request","title":"Your First Request","text":"<p>The simplest way to make a request is using the module-level functions:</p> <pre><code>import httpr\n\nresponse = httpr.get(\"https://httpbin.org/get\")\nprint(response.status_code)  # 200\nprint(response.json())\n</code></pre> <p>httpr provides functions for all common HTTP methods:</p> <pre><code>import httpr\n\n# GET\nresponse = httpr.get(\"https://httpbin.org/get\")\n\n# POST\nresponse = httpr.post(\"https://httpbin.org/post\", json={\"key\": \"value\"})\n\n# PUT\nresponse = httpr.put(\"https://httpbin.org/put\", json={\"key\": \"value\"})\n\n# PATCH\nresponse = httpr.patch(\"https://httpbin.org/patch\", json={\"key\": \"value\"})\n\n# DELETE\nresponse = httpr.delete(\"https://httpbin.org/delete\")\n\n# HEAD\nresponse = httpr.head(\"https://httpbin.org/get\")\n\n# OPTIONS\nresponse = httpr.options(\"https://httpbin.org/get\")\n</code></pre>"},{"location":"quickstart/#using-a-client","title":"Using a Client","text":"<p>For multiple requests, use a <code>Client</code> instance. This provides connection pooling and allows you to configure default settings:</p> <pre><code>import httpr\n\n# Create a client\nclient = httpr.Client()\n\n# Make multiple requests\nresponse1 = client.get(\"https://httpbin.org/get\")\nresponse2 = client.post(\"https://httpbin.org/post\", json={\"key\": \"value\"})\n\n# Always close when done (or use context manager)\nclient.close()\n</code></pre>"},{"location":"quickstart/#context-manager-recommended","title":"Context Manager (Recommended)","text":"<p>Use the context manager to ensure the client is properly closed:</p> <pre><code>import httpr\n\nwith httpr.Client() as client:\n    response = client.get(\"https://httpbin.org/get\")\n    print(response.json())\n# Client is automatically closed here\n</code></pre>"},{"location":"quickstart/#query-parameters","title":"Query Parameters","text":"<p>Add query parameters using the <code>params</code> argument:</p> <pre><code>import httpr\n\n# These are equivalent:\nresponse = httpr.get(\"https://httpbin.org/get?name=httpr&amp;version=1\")\nresponse = httpr.get(\"https://httpbin.org/get\", params={\"name\": \"httpr\", \"version\": \"1\"})\n\nprint(response.json()[\"args\"])  # {\"name\": \"httpr\", \"version\": \"1\"}\n</code></pre> <p>Numeric parameters are automatically converted to strings:</p> <pre><code>import httpr\n\nresponse = httpr.get(\"https://httpbin.org/get\", params={\"page\": 1, \"limit\": 10})\nprint(response.json()[\"args\"])  # {\"page\": \"1\", \"limit\": \"10\"}\n</code></pre>"},{"location":"quickstart/#request-headers","title":"Request Headers","text":"<p>Set custom headers using the <code>headers</code> argument:</p> <pre><code>import httpr\n\nresponse = httpr.get(\n    \"https://httpbin.org/headers\",\n    headers={\n        \"X-Custom-Header\": \"my-value\",\n        \"Accept\": \"application/json\"\n    }\n)\nprint(response.json()[\"headers\"][\"X-Custom-Header\"])  # \"my-value\"\n</code></pre>"},{"location":"quickstart/#sending-data","title":"Sending Data","text":""},{"location":"quickstart/#json-data","title":"JSON Data","text":"<p>Send JSON data using the <code>json</code> argument:</p> <pre><code>import httpr\n\nresponse = httpr.post(\n    \"https://httpbin.org/post\",\n    json={\"name\": \"httpr\", \"version\": 1, \"fast\": True}\n)\nprint(response.json()[\"json\"])  # {\"name\": \"httpr\", \"version\": 1, \"fast\": true}\n</code></pre>"},{"location":"quickstart/#form-data","title":"Form Data","text":"<p>Send form-encoded data using the <code>data</code> argument:</p> <pre><code>import httpr\n\nresponse = httpr.post(\n    \"https://httpbin.org/post\",\n    data={\"username\": \"user\", \"password\": \"secret\"}\n)\nprint(response.json()[\"form\"])  # {\"username\": \"user\", \"password\": \"secret\"}\n</code></pre>"},{"location":"quickstart/#binary-data","title":"Binary Data","text":"<p>Send raw bytes using the <code>content</code> argument:</p> <pre><code>import httpr\n\nresponse = httpr.post(\n    \"https://httpbin.org/post\",\n    content=b\"raw binary data\"\n)\nprint(response.json()[\"data\"])  # \"raw binary data\"\n</code></pre>"},{"location":"quickstart/#file-uploads","title":"File Uploads","text":"<p>Upload files using the <code>files</code> argument:</p> <pre><code>import httpr\n\nresponse = httpr.post(\n    \"https://httpbin.org/post\",\n    files={\n        \"document\": \"/path/to/file.txt\",\n        \"image\": \"/path/to/image.png\"\n    }\n)\n</code></pre> <p>Note</p> <p>The <code>files</code> argument takes a dictionary mapping field names to file paths.</p>"},{"location":"quickstart/#response-handling","title":"Response Handling","text":"<p>The response object provides several ways to access the response data:</p> <pre><code>import httpr\n\nresponse = httpr.get(\"https://httpbin.org/get\")\n\n# Status code\nprint(response.status_code)  # 200\n\n# Response body as text\nprint(response.text)\n\n# Response body as bytes\nprint(response.content)\n\n# Parse JSON response\ndata = response.json()\n\n# Response headers (case-insensitive)\nprint(response.headers[\"content-type\"])\nprint(response.headers[\"Content-Type\"])  # Same result\n\n# Response cookies\nprint(response.cookies)\n\n# Final URL (after redirects)\nprint(response.url)\n\n# Detected encoding\nprint(response.encoding)\n</code></pre>"},{"location":"quickstart/#html-to-text-conversion","title":"HTML to Text Conversion","text":"<p>httpr can convert HTML responses to plain text or markdown:</p> <pre><code>import httpr\n\nresponse = httpr.get(\"https://example.com\")\n\n# Convert HTML to Markdown\nprint(response.text_markdown)\n\n# Convert HTML to plain text\nprint(response.text_plain)\n\n# Convert HTML to rich text\nprint(response.text_rich)\n</code></pre>"},{"location":"quickstart/#streaming-responses","title":"Streaming Responses","text":"<p>For large responses, stream the data to avoid loading everything into memory:</p> <pre><code>import httpr\n\nwith httpr.Client() as client:\n    # Stream bytes\n    with client.stream(\"GET\", \"https://httpbin.org/stream-bytes/10000\") as response:\n        for chunk in response.iter_bytes():\n            process(chunk)  # Process each chunk as it arrives\n\n    # Stream text\n    with client.stream(\"GET\", \"https://httpbin.org/html\") as response:\n        for text in response.iter_text():\n            print(text, end=\"\")\n\n    # Stream lines (great for Server-Sent Events)\n    with client.stream(\"GET\", \"https://httpbin.org/stream/10\") as response:\n        for line in response.iter_lines():\n            print(line.strip())\n</code></pre> <p>Tip</p> <p>Headers, status code, and cookies are available immediately, before reading the body.</p>"},{"location":"quickstart/#timeouts","title":"Timeouts","text":"<p>Set a timeout in seconds to limit how long to wait for a response:</p> <pre><code>import httpr\n\n# Request-level timeout\nresponse = httpr.get(\"https://httpbin.org/delay/1\", timeout=5)\n\n# Client-level default timeout\nclient = httpr.Client(timeout=10)\nresponse = client.get(\"https://httpbin.org/get\")\n\n# Override client timeout for specific request\nresponse = client.get(\"https://httpbin.org/delay/5\", timeout=30)\n</code></pre>"},{"location":"quickstart/#redirects","title":"Redirects","text":"<p>By default, httpr follows redirects automatically:</p> <pre><code>import httpr\n\n# Follows redirects by default\nresponse = httpr.get(\"https://httpbin.org/redirect/3\")\nprint(response.url)  # Final URL after redirects\n\n# Disable redirects\nclient = httpr.Client(follow_redirects=False)\n\n# Limit number of redirects\nclient = httpr.Client(max_redirects=5)\n</code></pre>"},{"location":"quickstart/#whats-next","title":"What's Next?","text":"<ul> <li>Tutorial: Learn httpr step by step</li> <li>Authentication: Basic auth, bearer tokens</li> <li>Async Client: Async/await support</li> <li>SSL/TLS: Certificate configuration, mTLS</li> <li>API Reference: Complete API documentation</li> </ul>"},{"location":"advanced/","title":"Advanced Features","text":"<p>This section covers advanced httpr features for production use cases.</p> <ul> <li> <p> SSL/TLS &amp; mTLS</p> <p>Configure SSL certificates, CA bundles, and mutual TLS authentication.</p> <p> SSL/TLS Guide</p> </li> <li> <p> Proxy Configuration</p> <p>Route requests through HTTP and SOCKS proxies.</p> <p> Proxy Guide</p> </li> <li> <p> Cookie Handling</p> <p>Manage cookies with persistent cookie store and manual control.</p> <p> Cookie Guide</p> </li> </ul>"},{"location":"advanced/#overview","title":"Overview","text":""},{"location":"advanced/#ssltls","title":"SSL/TLS","text":"<p>httpr provides full SSL/TLS support:</p> <ul> <li>Certificate verification (enabled by default)</li> <li>Custom CA bundles for corporate/internal certificates</li> <li>mTLS (mutual TLS) for client certificate authentication</li> <li>HTTP/2 with TLS</li> </ul> <pre><code>import httpr\n\n# Custom CA certificate\nclient = httpr.Client(ca_cert_file=\"/path/to/ca-bundle.pem\")\n\n# mTLS with client certificate\nclient = httpr.Client(\n    client_pem=\"/path/to/client.pem\",\n    ca_cert_file=\"/path/to/ca-bundle.pem\"\n)\n</code></pre> <p> Learn more about SSL/TLS</p>"},{"location":"advanced/#proxy-support","title":"Proxy Support","text":"<p>Route requests through proxy servers:</p> <pre><code>import httpr\n\n# HTTP proxy\nclient = httpr.Client(proxy=\"http://proxy.example.com:8080\")\n\n# SOCKS5 proxy\nclient = httpr.Client(proxy=\"socks5://127.0.0.1:1080\")\n</code></pre> <p> Learn more about proxies</p>"},{"location":"advanced/#cookie-management","title":"Cookie Management","text":"<p>Automatic cookie handling with fine-grained control:</p> <pre><code>import httpr\n\n# Persistent cookie store (default)\nclient = httpr.Client(cookie_store=True)\n\n# Manual cookie management\nclient = httpr.Client(cookies={\"session\": \"abc123\"})\n</code></pre> <p> Learn more about cookies</p>"},{"location":"advanced/#environment-variables","title":"Environment Variables","text":"<p>httpr respects these environment variables:</p> Variable Description <code>HTTPR_PROXY</code> Default proxy URL <code>HTTPR_CA_BUNDLE</code> Path to CA certificate bundle <pre><code># Set proxy for all httpr clients\nexport HTTPR_PROXY=\"http://proxy:8080\"\n\n# Set CA bundle\nexport HTTPR_CA_BUNDLE=\"/etc/ssl/certs/ca-certificates.crt\"\n</code></pre>"},{"location":"advanced/#best-practices","title":"Best Practices","text":""},{"location":"advanced/#connection-pooling","title":"Connection Pooling","text":"<p>Use a single <code>Client</code> instance for multiple requests to the same host:</p> <pre><code>import httpr\n\n# Good: Reuse client\nwith httpr.Client() as client:\n    for url in urls:\n        response = client.get(url)\n\n# Bad: New client per request\nfor url in urls:\n    response = httpr.get(url)  # Creates new client each time\n</code></pre>"},{"location":"advanced/#timeout-configuration","title":"Timeout Configuration","text":"<p>Set appropriate timeouts for your use case:</p> <pre><code>import httpr\n\n# API calls - shorter timeout\napi_client = httpr.Client(timeout=10)\n\n# File downloads - longer timeout\ndownload_client = httpr.Client(timeout=300)\n</code></pre>"},{"location":"advanced/#error-handling","title":"Error Handling","text":"<pre><code>import httpr\n\ntry:\n    response = httpr.get(\"https://api.example.com/data\")\n    response_data = response.json()\nexcept Exception as e:\n    # Handle connection errors, timeouts, etc.\n    print(f\"Request failed: {e}\")\n</code></pre>"},{"location":"advanced/#resource-cleanup","title":"Resource Cleanup","text":"<p>Always close clients when done:</p> <pre><code>import httpr\n\n# Best: Context manager\nwith httpr.Client() as client:\n    response = client.get(url)\n\n# Alternative: Manual close\nclient = httpr.Client()\ntry:\n    response = client.get(url)\nfinally:\n    client.close()\n</code></pre>"},{"location":"advanced/cookies/","title":"Cookie Handling","text":"<p>httpr provides automatic cookie management with a persistent cookie store. This guide covers how cookies work and how to control them.</p>"},{"location":"advanced/cookies/#cookie-store","title":"Cookie Store","text":"<p>By default, httpr maintains a persistent cookie store that:</p> <ul> <li>Automatically stores cookies from <code>Set-Cookie</code> response headers</li> <li>Sends stored cookies with subsequent requests to matching domains</li> <li>Handles cookie expiration and path matching</li> </ul>"},{"location":"advanced/cookies/#default-behavior","title":"Default Behavior","text":"<pre><code>import httpr\n\nclient = httpr.Client(cookie_store=True)  # Default\n\n# First request - server sets a cookie\nclient.get(\"https://httpbin.org/cookies/set?session=abc123\")\n\n# Second request - cookie is automatically included\nresponse = client.get(\"https://httpbin.org/cookies\")\nprint(response.json())  # {\"cookies\": {\"session\": \"abc123\"}}\n</code></pre>"},{"location":"advanced/cookies/#disabling-cookie-store","title":"Disabling Cookie Store","text":"<p>For stateless requests, disable the cookie store:</p> <pre><code>import httpr\n\nclient = httpr.Client(cookie_store=False)\n\n# Cookie is set but not persisted\nclient.get(\"https://httpbin.org/cookies/set?session=abc123\")\n\n# Cookie not sent in subsequent request\nresponse = client.get(\"https://httpbin.org/cookies\")\nprint(response.json())  # {\"cookies\": {}}\n</code></pre>"},{"location":"advanced/cookies/#sending-cookies","title":"Sending Cookies","text":""},{"location":"advanced/cookies/#initial-cookies","title":"Initial Cookies","text":"<p>Set cookies when creating the client:</p> <pre><code>import httpr\n\nclient = httpr.Client(\n    cookies={\n        \"session\": \"abc123\",\n        \"user_id\": \"456\"\n    }\n)\n\nresponse = client.get(\"https://httpbin.org/cookies\")\nprint(response.json())  # {\"cookies\": {\"session\": \"abc123\", \"user_id\": \"456\"}}\n</code></pre>"},{"location":"advanced/cookies/#per-request-cookies","title":"Per-Request Cookies","text":"<p>Send cookies with specific requests:</p> <pre><code>import httpr\n\nclient = httpr.Client()\n\nresponse = client.get(\n    \"https://httpbin.org/cookies\",\n    cookies={\"temporary\": \"cookie-value\"}\n)\nprint(response.json())  # {\"cookies\": {\"temporary\": \"cookie-value\"}}\n</code></pre> <p>Per-request cookies are merged with client-level cookies:</p> <pre><code>import httpr\n\nclient = httpr.Client(cookies={\"persistent\": \"value1\"})\n\nresponse = client.get(\n    \"https://httpbin.org/cookies\",\n    cookies={\"temporary\": \"value2\"}\n)\n# Both cookies sent\nprint(response.json())  # {\"cookies\": {\"persistent\": \"value1\", \"temporary\": \"value2\"}}\n</code></pre>"},{"location":"advanced/cookies/#reading-cookies","title":"Reading Cookies","text":""},{"location":"advanced/cookies/#from-response","title":"From Response","text":"<p>Access cookies set by the server:</p> <pre><code>import httpr\n\nresponse = httpr.get(\"https://httpbin.org/cookies/set?name=value\")\nprint(response.cookies)  # {\"name\": \"value\"}\n</code></pre>"},{"location":"advanced/cookies/#from-client","title":"From Client","text":"<p>Get the current cookies on a client:</p> <pre><code>import httpr\n\nclient = httpr.Client(cookies={\"initial\": \"cookie\"})\nprint(client.cookies)  # {\"initial\": \"cookie\"}\n\n# After server sets more cookies\nclient.get(\"https://httpbin.org/cookies/set?new=cookie\")\n# Note: client.cookies may not reflect all cookies from cookie_store\n</code></pre>"},{"location":"advanced/cookies/#updating-cookies","title":"Updating Cookies","text":""},{"location":"advanced/cookies/#set-cookies","title":"Set Cookies","text":"<p>Update client cookies after creation:</p> <pre><code>import httpr\n\nclient = httpr.Client()\n\n# Set new cookies\nclient.cookies = {\"session\": \"new-session-id\"}\n\n# Read current cookies\nprint(client.cookies)  # {\"session\": \"new-session-id\"}\n</code></pre>"},{"location":"advanced/cookies/#clear-cookies","title":"Clear Cookies","text":"<p>Clear all client cookies:</p> <pre><code>import httpr\n\nclient = httpr.Client(cookies={\"old\": \"cookie\"})\n\n# Clear cookies\nclient.cookies = {}\n</code></pre>"},{"location":"advanced/cookies/#cookie-header-format","title":"Cookie Header Format","text":"<p>Cookies are sent as a single <code>Cookie</code> header:</p> <pre><code>import httpr\n\nresponse = httpr.get(\n    \"https://httpbin.org/headers\",\n    cookies={\"name1\": \"value1\", \"name2\": \"value2\"}\n)\n\n# Check the Cookie header that was sent\nheaders = response.json()[\"headers\"]\nprint(headers[\"Cookie\"])  # \"name1=value1; name2=value2\"\n</code></pre> <p>Note</p> <p>The <code>client.headers</code> getter excludes the <code>Cookie</code> header. Use <code>client.cookies</code> to access cookies separately.</p>"},{"location":"advanced/cookies/#use-cases","title":"Use Cases","text":""},{"location":"advanced/cookies/#session-management","title":"Session Management","text":"<p>Maintain authenticated sessions:</p> <pre><code>import httpr\n\nclass ApiSession:\n    \"\"\"Manage API session with cookies.\"\"\"\n\n    def __init__(self, base_url: str):\n        self.base_url = base_url\n        self.client = httpr.Client(cookie_store=True)\n\n    def login(self, username: str, password: str) -&gt; bool:\n        \"\"\"Login and store session cookie.\"\"\"\n        response = self.client.post(\n            f\"{self.base_url}/login\",\n            data={\"username\": username, \"password\": password}\n        )\n        return response.status_code == 200\n\n    def get_profile(self) -&gt; dict:\n        \"\"\"Get user profile (requires login).\"\"\"\n        response = self.client.get(f\"{self.base_url}/profile\")\n        return response.json()\n\n    def logout(self):\n        \"\"\"Logout and clear session.\"\"\"\n        self.client.post(f\"{self.base_url}/logout\")\n        self.client.cookies = {}\n\n    def close(self):\n        self.client.close()\n\n# Usage\nsession = ApiSession(\"https://api.example.com\")\nsession.login(\"user\", \"password\")\nprofile = session.get_profile()\nsession.logout()\nsession.close()\n</code></pre>"},{"location":"advanced/cookies/#testing-with-specific-cookies","title":"Testing with Specific Cookies","text":"<pre><code>import httpr\n\ndef test_authenticated_endpoint():\n    \"\"\"Test endpoint with mock session cookie.\"\"\"\n    client = httpr.Client(\n        cookies={\"session\": \"test-session-token\"},\n        cookie_store=False  # Don't persist new cookies\n    )\n\n    response = client.get(\"https://api.example.com/protected\")\n    assert response.status_code == 200\n</code></pre>"},{"location":"advanced/cookies/#multiple-sessions","title":"Multiple Sessions","text":"<p>Handle multiple user sessions:</p> <pre><code>import httpr\n\nclass MultiUserClient:\n    \"\"\"Manage multiple user sessions.\"\"\"\n\n    def __init__(self, base_url: str):\n        self.base_url = base_url\n        self.sessions: dict[str, httpr.Client] = {}\n\n    def get_session(self, user_id: str) -&gt; httpr.Client:\n        \"\"\"Get or create session for user.\"\"\"\n        if user_id not in self.sessions:\n            self.sessions[user_id] = httpr.Client(cookie_store=True)\n        return self.sessions[user_id]\n\n    def login(self, user_id: str, credentials: dict) -&gt; bool:\n        \"\"\"Login as specific user.\"\"\"\n        client = self.get_session(user_id)\n        response = client.post(f\"{self.base_url}/login\", data=credentials)\n        return response.status_code == 200\n\n    def request(self, user_id: str, method: str, path: str, **kwargs):\n        \"\"\"Make request as specific user.\"\"\"\n        client = self.get_session(user_id)\n        return client.request(method, f\"{self.base_url}{path}\", **kwargs)\n\n    def close(self):\n        \"\"\"Close all sessions.\"\"\"\n        for client in self.sessions.values():\n            client.close()\n</code></pre>"},{"location":"advanced/cookies/#cookie-debugging","title":"Cookie Debugging","text":"<p>Inspect cookies for debugging:</p> <pre><code>import httpr\n\ndef debug_cookies(url: str):\n    \"\"\"Debug cookie flow for a URL.\"\"\"\n    client = httpr.Client(cookie_store=True)\n\n    print(f\"Initial cookies: {client.cookies}\")\n\n    response = client.get(url)\n\n    print(f\"Response cookies: {response.cookies}\")\n    print(f\"Client cookies after: {client.cookies}\")\n\n    return response\n\ndebug_cookies(\"https://httpbin.org/cookies/set?debug=true\")\n</code></pre>"},{"location":"advanced/cookies/#cookie-behavior-details","title":"Cookie Behavior Details","text":""},{"location":"advanced/cookies/#cookie-store-vs-manual-cookies","title":"Cookie Store vs Manual Cookies","text":"Feature <code>cookie_store=True</code> <code>cookie_store=False</code> Store response cookies Yes No Send stored cookies Yes No Use <code>cookies</code> param Yes Yes Session persistence Yes No"},{"location":"advanced/cookies/#header-exclusion","title":"Header Exclusion","text":"<p>The <code>client.headers</code> property excludes the <code>Cookie</code> header:</p> <pre><code>import httpr\n\nclient = httpr.Client(\n    headers={\"X-Custom\": \"header\"},\n    cookies={\"session\": \"abc\"}\n)\n\nprint(client.headers)   # {\"x-custom\": \"header\"} - no Cookie header\nprint(client.cookies)   # {\"session\": \"abc\"}\n</code></pre> <p>This separation allows independent management of headers and cookies.</p>"},{"location":"advanced/cookies/#async-client","title":"Async Client","text":"<p>Cookie handling works identically with <code>AsyncClient</code>:</p> <pre><code>import asyncio\nimport httpr\n\nasync def main():\n    async with httpr.AsyncClient(cookie_store=True) as client:\n        # Set cookie\n        await client.get(\"https://httpbin.org/cookies/set?async=cookie\")\n\n        # Cookie persists\n        response = await client.get(\"https://httpbin.org/cookies\")\n        print(response.json())  # {\"cookies\": {\"async\": \"cookie\"}}\n\nasyncio.run(main())\n</code></pre>"},{"location":"advanced/proxy/","title":"Proxy Configuration","text":"<p>httpr supports routing requests through HTTP and SOCKS5 proxy servers.</p>"},{"location":"advanced/proxy/#basic-proxy-usage","title":"Basic Proxy Usage","text":""},{"location":"advanced/proxy/#http-proxy","title":"HTTP Proxy","text":"<pre><code>import httpr\n\nclient = httpr.Client(proxy=\"http://proxy.example.com:8080\")\nresponse = client.get(\"https://httpbin.org/ip\")\nprint(response.json())  # Shows proxy's IP\n</code></pre>"},{"location":"advanced/proxy/#https-proxy","title":"HTTPS Proxy","text":"<pre><code>import httpr\n\nclient = httpr.Client(proxy=\"https://secure-proxy.example.com:8443\")\nresponse = client.get(\"https://httpbin.org/ip\")\n</code></pre>"},{"location":"advanced/proxy/#socks5-proxy","title":"SOCKS5 Proxy","text":"<pre><code>import httpr\n\n# SOCKS5 proxy (e.g., Tor, SSH tunnel)\nclient = httpr.Client(proxy=\"socks5://127.0.0.1:1080\")\nresponse = client.get(\"https://httpbin.org/ip\")\n</code></pre>"},{"location":"advanced/proxy/#proxy-authentication","title":"Proxy Authentication","text":"<p>Include credentials in the proxy URL:</p> <pre><code>import httpr\n\n# HTTP proxy with auth\nclient = httpr.Client(\n    proxy=\"http://username:password@proxy.example.com:8080\"\n)\n\n# SOCKS5 proxy with auth\nclient = httpr.Client(\n    proxy=\"socks5://user:pass@127.0.0.1:1080\"\n)\n</code></pre>"},{"location":"advanced/proxy/#environment-variable","title":"Environment Variable","text":"<p>Set a default proxy using the <code>HTTPR_PROXY</code> environment variable:</p> <pre><code># Set for HTTP proxy\nexport HTTPR_PROXY=\"http://proxy.example.com:8080\"\n\n# Set for SOCKS5 proxy\nexport HTTPR_PROXY=\"socks5://127.0.0.1:1080\"\n</code></pre> <pre><code>import httpr\n\n# Automatically uses HTTPR_PROXY\nclient = httpr.Client()\nresponse = client.get(\"https://httpbin.org/ip\")\n</code></pre> <p>The <code>proxy</code> parameter takes precedence over the environment variable:</p> <pre><code>import httpr\n\n# Uses specified proxy, ignores HTTPR_PROXY\nclient = httpr.Client(proxy=\"http://other-proxy:8080\")\n</code></pre>"},{"location":"advanced/proxy/#changing-proxy-at-runtime","title":"Changing Proxy at Runtime","text":"<p>You can change the proxy on an existing client:</p> <pre><code>import httpr\n\nclient = httpr.Client()\n\n# Set proxy\nclient.proxy = \"http://proxy.example.com:8080\"\n\n# Read current proxy\nprint(client.proxy)  # \"http://proxy.example.com:8080\"\n\n# Remove proxy\nclient.proxy = None\n</code></pre> <p>Performance Note</p> <p>Changing the <code>proxy</code> property rebuilds the entire internal HTTP client. This is an expensive operation. For best performance, create separate clients for different proxy configurations.</p> <pre><code>import httpr\n\n# Better: Create separate clients\ndirect_client = httpr.Client()\nproxy_client = httpr.Client(proxy=\"http://proxy:8080\")\n\n# Avoid: Changing proxy repeatedly\nclient = httpr.Client()\nfor proxy in proxies:\n    client.proxy = proxy  # Rebuilds client each time!\n    client.get(url)\n</code></pre>"},{"location":"advanced/proxy/#use-cases","title":"Use Cases","text":""},{"location":"advanced/proxy/#corporate-proxy","title":"Corporate Proxy","text":"<p>Route traffic through a corporate proxy server:</p> <pre><code>import os\nimport httpr\n\ndef get_corporate_client() -&gt; httpr.Client:\n    \"\"\"Create client configured for corporate network.\"\"\"\n    proxy = os.environ.get(\"CORPORATE_PROXY\", \"http://proxy.corp:8080\")\n    ca_bundle = os.environ.get(\"CORPORATE_CA\", \"/etc/ssl/corp-ca.pem\")\n\n    return httpr.Client(\n        proxy=proxy,\n        ca_cert_file=ca_bundle,\n        timeout=30,\n    )\n\nwith get_corporate_client() as client:\n    response = client.get(\"https://api.example.com/data\")\n</code></pre>"},{"location":"advanced/proxy/#tor-network","title":"Tor Network","text":"<p>Route requests through Tor for anonymity:</p> <pre><code>import httpr\n\n# Tor SOCKS5 proxy (default port 9050)\ntor_client = httpr.Client(proxy=\"socks5://127.0.0.1:9050\")\n\n# Check Tor connection\nresponse = tor_client.get(\"https://check.torproject.org/api/ip\")\nprint(response.json())  # {\"IsTor\": true, \"IP\": \"...\"}\n</code></pre>"},{"location":"advanced/proxy/#ssh-tunnel","title":"SSH Tunnel","text":"<p>Use an SSH SOCKS tunnel:</p> <pre><code># Create SSH tunnel (in terminal)\nssh -D 1080 -N user@server.example.com\n</code></pre> <pre><code>import httpr\n\n# Use SSH tunnel\nclient = httpr.Client(proxy=\"socks5://127.0.0.1:1080\")\nresponse = client.get(\"https://httpbin.org/ip\")\n</code></pre>"},{"location":"advanced/proxy/#rotating-proxies","title":"Rotating Proxies","text":"<p>Use different proxies for different requests:</p> <pre><code>import httpr\n\nproxies = [\n    \"http://proxy1.example.com:8080\",\n    \"http://proxy2.example.com:8080\",\n    \"http://proxy3.example.com:8080\",\n]\n\ndef fetch_with_rotation(urls: list[str]) -&gt; list[dict]:\n    \"\"\"Fetch URLs using rotating proxies.\"\"\"\n    results = []\n\n    for i, url in enumerate(urls):\n        proxy = proxies[i % len(proxies)]\n\n        with httpr.Client(proxy=proxy) as client:\n            response = client.get(url)\n            results.append({\n                \"url\": url,\n                \"proxy\": proxy,\n                \"status\": response.status_code\n            })\n\n    return results\n</code></pre>"},{"location":"advanced/proxy/#conditional-proxy","title":"Conditional Proxy","text":"<p>Use proxy only for certain hosts:</p> <pre><code>import httpr\nfrom urllib.parse import urlparse\n\nclass ProxyRouter:\n    \"\"\"Route requests through proxy based on host.\"\"\"\n\n    def __init__(self, proxy: str, proxy_hosts: set[str]):\n        self.proxy_client = httpr.Client(proxy=proxy)\n        self.direct_client = httpr.Client()\n        self.proxy_hosts = proxy_hosts\n\n    def get(self, url: str, **kwargs):\n        host = urlparse(url).netloc\n        if host in self.proxy_hosts:\n            return self.proxy_client.get(url, **kwargs)\n        return self.direct_client.get(url, **kwargs)\n\n    def close(self):\n        self.proxy_client.close()\n        self.direct_client.close()\n\n# Usage\nrouter = ProxyRouter(\n    proxy=\"http://proxy:8080\",\n    proxy_hosts={\"api.external.com\", \"data.external.com\"}\n)\n\n# Direct connection\nrouter.get(\"https://api.internal.com/data\")\n\n# Through proxy\nrouter.get(\"https://api.external.com/data\")\n</code></pre>"},{"location":"advanced/proxy/#async-client-with-proxy","title":"Async Client with Proxy","text":"<p>Proxy configuration works the same with <code>AsyncClient</code>:</p> <pre><code>import asyncio\nimport httpr\n\nasync def main():\n    async with httpr.AsyncClient(proxy=\"http://proxy:8080\") as client:\n        response = await client.get(\"https://httpbin.org/ip\")\n        print(response.json())\n\nasyncio.run(main())\n</code></pre>"},{"location":"advanced/proxy/#supported-proxy-protocols","title":"Supported Proxy Protocols","text":"Protocol URL Format Notes HTTP <code>http://host:port</code> Most common HTTPS <code>https://host:port</code> Encrypted proxy connection SOCKS5 <code>socks5://host:port</code> Supports TCP <p>Note</p> <p>SOCKS4 and SOCKS4a are not currently supported. Use SOCKS5 instead.</p>"},{"location":"advanced/proxy/#troubleshooting","title":"Troubleshooting","text":""},{"location":"advanced/proxy/#connection-refused","title":"Connection Refused","text":"<pre><code>connection refused\n</code></pre> <ul> <li>Verify proxy host and port are correct</li> <li>Check if proxy server is running</li> <li>Ensure firewall allows connection to proxy</li> </ul>"},{"location":"advanced/proxy/#authentication-failed","title":"Authentication Failed","text":"<pre><code>proxy authentication required\n</code></pre> <ul> <li>Include credentials in proxy URL: <code>http://user:pass@proxy:8080</code></li> <li>Verify credentials are correct</li> <li>Check if proxy requires specific auth method</li> </ul>"},{"location":"advanced/proxy/#timeout-through-proxy","title":"Timeout Through Proxy","text":"<ul> <li>Increase timeout: <code>httpr.Client(proxy=proxy, timeout=60)</code></li> <li>Proxy may be slow or overloaded</li> <li>Try a different proxy server</li> </ul>"},{"location":"advanced/proxy/#ssl-errors-through-proxy","title":"SSL Errors Through Proxy","text":"<ul> <li>Some proxies intercept HTTPS traffic</li> <li>May need to add proxy's CA certificate to <code>ca_cert_file</code></li> <li>Or use SOCKS5 proxy for end-to-end encryption</li> </ul>"},{"location":"advanced/ssl-tls/","title":"SSL/TLS &amp; mTLS","text":"<p>This guide covers SSL/TLS configuration in httpr, including certificate verification, custom CA bundles, and mutual TLS (mTLS) authentication.</p>"},{"location":"advanced/ssl-tls/#overview","title":"Overview","text":"<p>By default, httpr verifies SSL/TLS certificates using the system's certificate store. You can customize this behavior for:</p> <ul> <li>Corporate/internal certificates</li> <li>Self-signed certificates (development)</li> <li>Client certificate authentication (mTLS)</li> </ul>"},{"location":"advanced/ssl-tls/#certificate-verification","title":"Certificate Verification","text":""},{"location":"advanced/ssl-tls/#default-behavior","title":"Default Behavior","text":"<p>SSL certificate verification is enabled by default:</p> <pre><code>import httpr\n\n# Verification enabled (default)\nclient = httpr.Client(verify=True)\nresponse = client.get(\"https://example.com\")  # Certificate is verified\n</code></pre>"},{"location":"advanced/ssl-tls/#disabling-verification","title":"Disabling Verification","text":"<p>Security Warning</p> <p>Disabling certificate verification exposes you to man-in-the-middle attacks. Only use this for local development or testing.</p> <pre><code>import httpr\n\n# Disable verification (insecure!)\nclient = httpr.Client(verify=False)\nresponse = client.get(\"https://self-signed.badssl.com/\")\n</code></pre>"},{"location":"advanced/ssl-tls/#custom-ca-certificates","title":"Custom CA Certificates","text":""},{"location":"advanced/ssl-tls/#using-a-custom-ca-bundle","title":"Using a Custom CA Bundle","text":"<p>For corporate environments or internal services with custom certificate authorities:</p> <pre><code>import httpr\n\n# Specify custom CA bundle\nclient = httpr.Client(ca_cert_file=\"/path/to/ca-bundle.pem\")\nresponse = client.get(\"https://internal.company.com/api\")\n</code></pre>"},{"location":"advanced/ssl-tls/#using-certifi","title":"Using certifi","text":"<p>The popular <code>certifi</code> package provides Mozilla's CA bundle:</p> <pre><code>import certifi\nimport httpr\n\nclient = httpr.Client(ca_cert_file=certifi.where())\nresponse = client.get(\"https://example.com\")\n</code></pre>"},{"location":"advanced/ssl-tls/#environment-variable","title":"Environment Variable","text":"<p>Set the CA bundle via environment variable:</p> <pre><code>export HTTPR_CA_BUNDLE=\"/etc/ssl/certs/ca-certificates.crt\"\n</code></pre> <pre><code>import httpr\n\n# Automatically uses HTTPR_CA_BUNDLE\nclient = httpr.Client()\n</code></pre> <p>Note</p> <p>The <code>ca_cert_file</code> parameter internally sets the <code>HTTPR_CA_BUNDLE</code> environment variable.</p>"},{"location":"advanced/ssl-tls/#mtls-mutual-tls","title":"mTLS (Mutual TLS)","text":"<p>Mutual TLS requires both the server and client to present certificates. This is common in:</p> <ul> <li>Zero-trust architectures</li> <li>Service mesh communication</li> <li>Banking and financial APIs</li> <li>IoT device authentication</li> </ul>"},{"location":"advanced/ssl-tls/#configuration","title":"Configuration","text":"<pre><code>import httpr\n\nclient = httpr.Client(\n    client_pem=\"/path/to/client-cert.pem\",  # Client certificate + key\n    ca_cert_file=\"/path/to/ca-bundle.pem\"    # CA to verify server\n)\n\nresponse = client.get(\"https://mtls.example.com/api\")\n</code></pre>"},{"location":"advanced/ssl-tls/#certificate-format","title":"Certificate Format","text":"<p>The <code>client_pem</code> file should contain both the certificate and private key in PEM format:</p> <pre><code>-----BEGIN CERTIFICATE-----\nMIIDXTCCAkWgAwIBAgIJAJC1HiIAZAiUMA0Gcq...\n-----END CERTIFICATE-----\n-----BEGIN PRIVATE KEY-----\nMIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwgg...\n-----END PRIVATE KEY-----\n</code></pre>"},{"location":"advanced/ssl-tls/#complete-mtls-example","title":"Complete mTLS Example","text":"<pre><code>import httpr\n\ndef create_mtls_client(\n    client_cert: str,\n    ca_bundle: str,\n    timeout: float = 30\n) -&gt; httpr.Client:\n    \"\"\"Create a client configured for mTLS.\"\"\"\n    return httpr.Client(\n        client_pem=client_cert,\n        ca_cert_file=ca_bundle,\n        timeout=timeout,\n        verify=True,  # Must be True for mTLS\n    )\n\n# Usage\nclient = create_mtls_client(\n    client_cert=\"/certs/client.pem\",\n    ca_bundle=\"/certs/ca.pem\"\n)\n\nwith client:\n    response = client.get(\"https://secure-api.example.com/data\")\n    print(response.json())\n</code></pre>"},{"location":"advanced/ssl-tls/#http2","title":"HTTP/2","text":"<p>httpr supports HTTP/2 over TLS:</p> <pre><code>import httpr\n\n# HTTP/2 only mode\nclient = httpr.Client(http2_only=True)\nresponse = client.get(\"https://http2.example.com\")\n</code></pre> <p>Note</p> <p>HTTP/2 requires TLS. The <code>http2_only</code> option forces HTTP/2 protocol. When <code>http2_only=False</code> (default), httpr uses HTTP/1.1.</p>"},{"location":"advanced/ssl-tls/#https-only-mode","title":"HTTPS Only Mode","text":"<p>Restrict the client to HTTPS connections only:</p> <pre><code>import httpr\n\nclient = httpr.Client(https_only=True)\n\n# Works\nresponse = client.get(\"https://example.com\")\n\n# Raises an error\n# response = client.get(\"http://example.com\")\n</code></pre> <p>This is useful for ensuring all traffic is encrypted, especially when handling sensitive data.</p>"},{"location":"advanced/ssl-tls/#testing-with-self-signed-certificates","title":"Testing with Self-Signed Certificates","text":"<p>For local development with self-signed certificates:</p>"},{"location":"advanced/ssl-tls/#using-trustme-python-testing","title":"Using trustme (Python testing)","text":"<pre><code>import trustme\nimport httpr\n\n# Generate test CA and certificates\nca = trustme.CA()\nserver_cert = ca.issue_cert(\"localhost\")\n\n# Export certificates\nca.cert_pem.write_to_path(\"test-ca.pem\")\nserver_cert.private_key_and_cert_chain_pem.write_to_path(\"server.pem\")\n\n# Use in httpr\nclient = httpr.Client(ca_cert_file=\"test-ca.pem\")\n</code></pre>"},{"location":"advanced/ssl-tls/#development-configuration","title":"Development Configuration","text":"<pre><code>import os\nimport httpr\n\ndef get_client() -&gt; httpr.Client:\n    \"\"\"Get configured client based on environment.\"\"\"\n    if os.environ.get(\"ENVIRONMENT\") == \"development\":\n        # Development: Use test CA or disable verification\n        return httpr.Client(\n            ca_cert_file=os.environ.get(\"DEV_CA_BUNDLE\"),\n            verify=bool(os.environ.get(\"DEV_CA_BUNDLE\"))\n        )\n    else:\n        # Production: Use system CA bundle\n        return httpr.Client(verify=True)\n</code></pre>"},{"location":"advanced/ssl-tls/#troubleshooting","title":"Troubleshooting","text":""},{"location":"advanced/ssl-tls/#certificate-errors","title":"Certificate Errors","text":"<p>\"certificate verify failed\"</p> <p>The server's certificate is not trusted:</p> <ol> <li>Check if the certificate is expired</li> <li>Verify the CA bundle includes the issuing CA</li> <li>For internal CAs, specify the correct <code>ca_cert_file</code></li> </ol> <pre><code>import httpr\n\n# Try with certifi's CA bundle\nimport certifi\nclient = httpr.Client(ca_cert_file=certifi.where())\n</code></pre> <p>\"unable to get local issuer certificate\"</p> <p>The CA certificate chain is incomplete:</p> <ol> <li>Ensure your CA bundle includes intermediate certificates</li> <li>Try using a complete CA bundle</li> </ol> <p>\"wrong version number\" or \"SSL handshake failed\"</p> <p>Protocol mismatch:</p> <ol> <li>Server may not support modern TLS versions</li> <li>Try <code>http2_only=False</code> if using HTTP/2</li> </ol>"},{"location":"advanced/ssl-tls/#mtls-errors","title":"mTLS Errors","text":"<p>\"no client certificate presented\"</p> <ol> <li>Verify <code>client_pem</code> file path is correct</li> <li>Check the PEM file contains both cert and key</li> <li>Ensure <code>verify=True</code> is set</li> </ol> <p>\"certificate signature failure\"</p> <ol> <li>Client certificate not signed by expected CA</li> <li>Certificate may have been revoked</li> </ol>"},{"location":"advanced/ssl-tls/#security-recommendations","title":"Security Recommendations","text":"<ol> <li> <p>Always verify certificates in production - Never use <code>verify=False</code></p> </li> <li> <p>Keep CA bundles updated - Use system CA or update certifi regularly</p> </li> <li> <p>Protect private keys - Secure <code>client_pem</code> files with appropriate permissions</p> </li> <li> <p>Use HTTPS everywhere - Consider <code>https_only=True</code> for sensitive applications</p> </li> <li> <p>Rotate certificates - Implement certificate rotation for mTLS</p> </li> </ol> <pre><code>import httpr\n\n# Production-ready client\nclient = httpr.Client(\n    verify=True,           # Always verify\n    https_only=True,       # HTTPS only\n    timeout=30,            # Reasonable timeout\n    # ca_cert_file=...,    # Custom CA if needed\n    # client_pem=...,      # mTLS if required\n)\n</code></pre>"},{"location":"api/","title":"API Reference","text":"<p>Complete API documentation for httpr.</p>"},{"location":"api/#overview","title":"Overview","text":"<p>httpr provides a simple, intuitive API for making HTTP requests:</p> Component Description <code>Client</code> Synchronous HTTP client with connection pooling <code>AsyncClient</code> Asynchronous HTTP client for asyncio <code>Response</code> HTTP response with body, headers, and metadata Module Functions Convenience functions for one-off requests"},{"location":"api/#quick-reference","title":"Quick Reference","text":""},{"location":"api/#client-configuration","title":"Client Configuration","text":"<pre><code>import httpr\n\nclient = httpr.Client(\n    # Authentication\n    auth=(\"username\", \"password\"),    # Basic auth\n    auth_bearer=\"token\",              # Bearer token\n\n    # Request defaults\n    headers={\"User-Agent\": \"my-app\"},\n    cookies={\"session\": \"abc\"},\n    params={\"api_version\": \"v2\"},\n    timeout=30,\n\n    # Cookie handling\n    cookie_store=True,                # Persistent cookies\n    referer=True,                     # Auto Referer header\n\n    # Network\n    proxy=\"http://proxy:8080\",\n    follow_redirects=True,\n    max_redirects=20,\n\n    # SSL/TLS\n    verify=True,\n    ca_cert_file=\"/path/to/ca.pem\",\n    client_pem=\"/path/to/client.pem\", # mTLS\n\n    # Protocol\n    https_only=False,\n    http2_only=False,\n)\n</code></pre>"},{"location":"api/#request-parameters","title":"Request Parameters","text":"<pre><code>response = client.get(\n    \"https://api.example.com/data\",\n    params={\"key\": \"value\"},          # Query params\n    headers={\"Accept\": \"application/json\"},\n    cookies={\"session\": \"xyz\"},\n    auth=(\"user\", \"pass\"),            # Override client auth\n    auth_bearer=\"token\",              # Or bearer token\n    timeout=60,                       # Override timeout\n)\n\nresponse = client.post(\n    \"https://api.example.com/data\",\n    json={\"key\": \"value\"},            # JSON body\n    # OR\n    data={\"field\": \"value\"},          # Form body\n    # OR\n    content=b\"raw bytes\",             # Binary body\n    # OR\n    files={\"doc\": \"/path/to/file\"},   # Multipart upload\n)\n</code></pre>"},{"location":"api/#response-object","title":"Response Object","text":"<pre><code>response = client.get(\"https://api.example.com\")\n\n# Status\nresponse.status_code      # int: 200, 404, etc.\n\n# Body\nresponse.text             # str: decoded text\nresponse.content          # bytes: raw bytes\nresponse.json()           # Any: parsed JSON\n\n# Headers &amp; Cookies\nresponse.headers          # dict-like, case-insensitive\nresponse.cookies          # dict[str, str]\n\n# Metadata\nresponse.url              # str: final URL (after redirects)\nresponse.encoding         # str: detected encoding\n\n# HTML conversion\nresponse.text_markdown    # HTML to Markdown\nresponse.text_plain       # HTML to plain text\n</code></pre>"},{"location":"api/#module-contents","title":"Module Contents","text":"<p>httpr - Blazing fast HTTP client for Python, built in Rust.</p> <p>httpr is a high-performance HTTP client that can be used as a drop-in replacement for <code>httpx</code> and <code>requests</code> in most cases.</p> Example <p>Simple GET request:</p> <pre><code>import httpr\n\nresponse = httpr.get(\"https://httpbin.org/get\")\nprint(response.json())\n</code></pre> <p>Using a client for connection pooling:</p> <pre><code>import httpr\n\nwith httpr.Client() as client:\n    response = client.get(\"https://httpbin.org/get\")\n    print(response.status_code)\n</code></pre>"},{"location":"api/async-client/","title":"AsyncClient","text":"<p>The asynchronous HTTP client for use with asyncio.</p>"},{"location":"api/async-client/#httpr.AsyncClient","title":"AsyncClient","text":"<pre><code>AsyncClient(*args, **kwargs)\n</code></pre> <p>An asynchronous HTTP client for use with asyncio.</p> <p>AsyncClient wraps the synchronous Client using asyncio.run_in_executor(), providing an async interface while leveraging the Rust implementation's performance.</p> Example <p>Basic usage:</p> <pre><code>import asyncio\nimport httpr\n\nasync def main():\n    async with httpr.AsyncClient() as client:\n        response = await client.get(\"https://httpbin.org/get\")\n        print(response.json())\n\nasyncio.run(main())\n</code></pre> <p>Concurrent requests:</p> <pre><code>import asyncio\nimport httpr\n\nasync def main():\n    async with httpr.AsyncClient() as client:\n        tasks = [\n            client.get(\"https://httpbin.org/get\"),\n            client.get(\"https://httpbin.org/ip\"),\n        ]\n        responses = await asyncio.gather(*tasks)\n        for response in responses:\n            print(response.json())\n\nasyncio.run(main())\n</code></pre> Note <p>AsyncClient runs synchronous Rust code in a thread executor. It provides concurrency benefits for I/O-bound tasks but is not native async I/O.</p> <p>Initialize an async HTTP client.</p> <p>Accepts the same parameters as Client.</p>"},{"location":"api/async-client/#httpr.AsyncClient.request","title":"request  <code>async</code>","text":"<pre><code>request(method: HttpMethod, url: str, **kwargs: Unpack[RequestParams]) -&gt; Response\n</code></pre> <p>Make an async HTTP request.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>HttpMethod</code> <p>HTTP method.</p> required <code>url</code> <code>str</code> <p>Request URL.</p> required <code>**kwargs</code> <code>Unpack[RequestParams]</code> <p>Request parameters.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>Response object.</p> Example <pre><code>response = await client.request(\"GET\", \"https://httpbin.org/get\")\n</code></pre>"},{"location":"api/async-client/#httpr.AsyncClient.get","title":"get  <code>async</code>","text":"<pre><code>get(url: str, **kwargs: Unpack[RequestParams]) -&gt; Response\n</code></pre> <p>Make an async GET request.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Request URL.</p> required <code>**kwargs</code> <code>Unpack[RequestParams]</code> <p>Request parameters.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>Response object.</p> Example <pre><code>response = await client.get(\"https://httpbin.org/get\")\n</code></pre>"},{"location":"api/async-client/#httpr.AsyncClient.head","title":"head  <code>async</code>","text":"<pre><code>head(url: str, **kwargs: Unpack[RequestParams]) -&gt; Response\n</code></pre> <p>Make an async HEAD request.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Request URL.</p> required <code>**kwargs</code> <code>Unpack[RequestParams]</code> <p>Request parameters.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>Response object.</p>"},{"location":"api/async-client/#httpr.AsyncClient.options","title":"options  <code>async</code>","text":"<pre><code>options(url: str, **kwargs: Unpack[RequestParams]) -&gt; Response\n</code></pre> <p>Make an async OPTIONS request.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Request URL.</p> required <code>**kwargs</code> <code>Unpack[RequestParams]</code> <p>Request parameters.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>Response object.</p>"},{"location":"api/async-client/#httpr.AsyncClient.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(url: str, **kwargs: Unpack[RequestParams]) -&gt; Response\n</code></pre> <p>Make an async DELETE request.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Request URL.</p> required <code>**kwargs</code> <code>Unpack[RequestParams]</code> <p>Request parameters.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>Response object.</p>"},{"location":"api/async-client/#httpr.AsyncClient.post","title":"post  <code>async</code>","text":"<pre><code>post(url: str, **kwargs: Unpack[RequestParams]) -&gt; Response\n</code></pre> <p>Make an async POST request.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Request URL.</p> required <code>**kwargs</code> <code>Unpack[RequestParams]</code> <p>Request parameters including body options.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>Response object.</p> Example <pre><code>response = await client.post(\n    \"https://httpbin.org/post\",\n    json={\"key\": \"value\"},\n)\n</code></pre>"},{"location":"api/async-client/#httpr.AsyncClient.put","title":"put  <code>async</code>","text":"<pre><code>put(url: str, **kwargs: Unpack[RequestParams]) -&gt; Response\n</code></pre> <p>Make an async PUT request.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Request URL.</p> required <code>**kwargs</code> <code>Unpack[RequestParams]</code> <p>Request parameters including body options.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>Response object.</p>"},{"location":"api/async-client/#httpr.AsyncClient.patch","title":"patch  <code>async</code>","text":"<pre><code>patch(url: str, **kwargs: Unpack[RequestParams]) -&gt; Response\n</code></pre> <p>Make an async PATCH request.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Request URL.</p> required <code>**kwargs</code> <code>Unpack[RequestParams]</code> <p>Request parameters including body options.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>Response object.</p>"},{"location":"api/async-client/#httpr.AsyncClient.stream","title":"stream  <code>async</code>","text":"<pre><code>stream(method: HttpMethod, url: str, **kwargs: Unpack[RequestParams]) -&gt; AsyncIterator[StreamingResponse]\n</code></pre> <p>Make an async streaming HTTP request.</p> <p>Returns an async context manager that yields a StreamingResponse for iterating over the response body in chunks.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>HttpMethod</code> <p>HTTP method.</p> required <code>url</code> <code>str</code> <p>Request URL.</p> required <code>**kwargs</code> <code>Unpack[RequestParams]</code> <p>Request parameters.</p> <code>{}</code> <p>Yields:</p> Name Type Description <code>StreamingResponse</code> <code>AsyncIterator[StreamingResponse]</code> <p>A response object that can be iterated.</p> Example <pre><code>async with client.stream(\"GET\", \"https://example.com/large-file\") as response:\n    for chunk in response.iter_bytes():\n        process(chunk)\n</code></pre> Note <p>Iteration over the response is synchronous (uses iter_bytes, iter_text, iter_lines). The async part is initiating the request and entering the context manager.</p>"},{"location":"api/async-client/#httpr.AsyncClient.aclose","title":"aclose  <code>async</code>","text":"<pre><code>aclose()\n</code></pre> <p>Close the async client.</p> Example <pre><code>client = httpr.AsyncClient()\ntry:\n    response = await client.get(\"https://example.com\")\nfinally:\n    await client.aclose()\n</code></pre>"},{"location":"api/client/","title":"Client","text":"<p>The synchronous HTTP client with connection pooling.</p>"},{"location":"api/client/#httpr.Client","title":"Client","text":"<pre><code>Client(auth: tuple[str, str | None] | None = None, auth_bearer: str | None = None, params: dict[str, str] | None = None, headers: dict[str, str] | None = None, cookies: dict[str, str] | None = None, cookie_store: bool | None = True, referer: bool | None = True, proxy: str | None = None, timeout: float | None = 30, follow_redirects: bool | None = True, max_redirects: int | None = 20, verify: bool | None = True, ca_cert_file: str | None = None, client_pem: str | None = None, https_only: bool | None = False, http2_only: bool | None = False)\n</code></pre> <p>A synchronous HTTP client with connection pooling.</p> <p>The Client class provides a high-level interface for making HTTP requests. It supports connection pooling, automatic cookie handling, and various authentication methods.</p> Example <p>Basic usage:</p> <pre><code>import httpr\n\n# Using context manager (recommended)\nwith httpr.Client() as client:\n    response = client.get(\"https://httpbin.org/get\")\n    print(response.json())\n\n# Or manually\nclient = httpr.Client()\nresponse = client.get(\"https://httpbin.org/get\")\nclient.close()\n</code></pre> <p>With configuration:</p> <pre><code>import httpr\n\nclient = httpr.Client(\n    auth_bearer=\"your-api-token\",\n    headers={\"User-Agent\": \"my-app/1.0\"},\n    timeout=30,\n)\n</code></pre> <p>Attributes:</p> Name Type Description <code>headers</code> <code>dict[str, str]</code> <p>Default headers sent with all requests. Excludes Cookie header.</p> <code>cookies</code> <code>dict[str, str]</code> <p>Default cookies sent with all requests.</p> <code>auth</code> <code>tuple[str, str | None] | None</code> <p>Basic auth credentials as (username, password) tuple.</p> <code>params</code> <code>dict[str, str] | None</code> <p>Default query parameters added to all requests.</p> <code>timeout</code> <code>float | None</code> <p>Default timeout in seconds.</p> <code>proxy</code> <code>str | None</code> <p>Proxy URL for requests.</p> <p>Initialize an HTTP client.</p> <p>Parameters:</p> Name Type Description Default <code>auth</code> <code>tuple[str, str | None] | None</code> <p>Basic auth credentials as (username, password). Password can be None.</p> <code>None</code> <code>auth_bearer</code> <code>str | None</code> <p>Bearer token for Authorization header.</p> <code>None</code> <code>params</code> <code>dict[str, str] | None</code> <p>Default query parameters to include in all requests.</p> <code>None</code> <code>headers</code> <code>dict[str, str] | None</code> <p>Default headers to send with all requests.</p> <code>None</code> <code>cookies</code> <code>dict[str, str] | None</code> <p>Default cookies to send with all requests.</p> <code>None</code> <code>cookie_store</code> <code>bool | None</code> <p>Enable persistent cookie store. Cookies from responses will be preserved and included in subsequent requests. Default is True.</p> <code>True</code> <code>referer</code> <code>bool | None</code> <p>Automatically set Referer header. Default is True.</p> <code>True</code> <code>proxy</code> <code>str | None</code> <p>Proxy URL (e.g., \"http://proxy:8080\" or \"socks5://127.0.0.1:1080\"). Falls back to HTTPR_PROXY environment variable.</p> <code>None</code> <code>timeout</code> <code>float | None</code> <p>Request timeout in seconds. Default is 30.</p> <code>30</code> <code>follow_redirects</code> <code>bool | None</code> <p>Follow HTTP redirects. Default is True.</p> <code>True</code> <code>max_redirects</code> <code>int | None</code> <p>Maximum redirects to follow. Default is 20.</p> <code>20</code> <code>verify</code> <code>bool | None</code> <p>Verify SSL certificates. Default is True.</p> <code>True</code> <code>ca_cert_file</code> <code>str | None</code> <p>Path to CA certificate bundle (PEM format).</p> <code>None</code> <code>client_pem</code> <code>str | None</code> <p>Path to client certificate for mTLS (PEM format).</p> <code>None</code> <code>https_only</code> <code>bool | None</code> <p>Only allow HTTPS requests. Default is False.</p> <code>False</code> <code>http2_only</code> <code>bool | None</code> <p>Use HTTP/2 only (False uses HTTP/1.1). Default is False.</p> <code>False</code> Example <pre><code>import httpr\n\n# Simple client\nclient = httpr.Client()\n\n# Client with authentication\nclient = httpr.Client(\n    auth=(\"username\", \"password\"),\n    timeout=60,\n)\n\n# Client with bearer token\nclient = httpr.Client(\n    auth_bearer=\"your-api-token\",\n    headers={\"Accept\": \"application/json\"},\n)\n\n# Client with proxy\nclient = httpr.Client(proxy=\"http://proxy.example.com:8080\")\n\n# Client with mTLS\nclient = httpr.Client(\n    client_pem=\"/path/to/client.pem\",\n    ca_cert_file=\"/path/to/ca.pem\",\n)\n</code></pre>"},{"location":"api/client/#httpr.Client.request","title":"request","text":"<pre><code>request(method: HttpMethod, url: str, **kwargs: Unpack[RequestParams]) -&gt; Response\n</code></pre> <p>Make an HTTP request.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>HttpMethod</code> <p>HTTP method (GET, POST, PUT, PATCH, DELETE, HEAD, OPTIONS).</p> required <code>url</code> <code>str</code> <p>Request URL.</p> required <code>**kwargs</code> <code>Unpack[RequestParams]</code> <p>Request parameters (see below).</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>params</code> <code>Optional[dict[str, str]]</code> <p>Query parameters to append to URL.</p> <code>headers</code> <code>Optional[dict[str, str]]</code> <p>Request headers (merged with client defaults).</p> <code>cookies</code> <code>Optional[dict[str, str]]</code> <p>Request cookies (merged with client defaults).</p> <code>auth</code> <code>Optional[tuple[str, Optional[str]]]</code> <p>Basic auth credentials (overrides client default).</p> <code>auth_bearer</code> <code>Optional[str]</code> <p>Bearer token (overrides client default).</p> <code>timeout</code> <code>Optional[float]</code> <p>Request timeout in seconds (overrides client default).</p> <code>content</code> <code>Optional[bytes]</code> <p>Raw bytes for request body.</p> <code>data</code> <code>Optional[dict[str, Any]]</code> <p>Form data for request body (application/x-www-form-urlencoded).</p> <code>json</code> <code>Optional[Any]</code> <p>JSON data for request body (application/json).</p> <code>files</code> <code>Optional[dict[str, str]]</code> <p>Files for multipart upload (dict mapping field names to file paths).</p> <p>Returns:</p> Type Description <code>Response</code> <p>Response object with status, headers, and body.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If method is not a valid HTTP method.</p> <code>Exception</code> <p>If request fails (timeout, connection error, etc.).</p> Example <pre><code>response = client.request(\"GET\", \"https://httpbin.org/get\")\nresponse = client.request(\"POST\", \"https://httpbin.org/post\", json={\"key\": \"value\"})\n</code></pre> Note <p>Only one of <code>content</code>, <code>data</code>, <code>json</code>, or <code>files</code> can be specified per request.</p>"},{"location":"api/client/#httpr.Client.get","title":"get","text":"<pre><code>get(url: str, **kwargs: Unpack[RequestParams]) -&gt; Response\n</code></pre> <p>Make a GET request.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Request URL.</p> required <code>**kwargs</code> <code>Unpack[RequestParams]</code> <p>Request parameters (params, headers, cookies, auth, auth_bearer, timeout).</p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>Response object.</p> Example <pre><code>response = client.get(\n    \"https://httpbin.org/get\",\n    params={\"key\": \"value\"},\n    headers={\"Accept\": \"application/json\"},\n)\nprint(response.json())\n</code></pre>"},{"location":"api/client/#httpr.Client.head","title":"head","text":"<pre><code>head(url: str, **kwargs: Unpack[RequestParams]) -&gt; Response\n</code></pre> <p>Make a HEAD request.</p> <p>Returns only headers, no response body.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Request URL.</p> required <code>**kwargs</code> <code>Unpack[RequestParams]</code> <p>Request parameters (params, headers, cookies, auth, auth_bearer, timeout).</p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>Response object (body will be empty).</p> Example <pre><code>response = client.head(\"https://httpbin.org/get\")\nprint(response.headers[\"content-length\"])\n</code></pre>"},{"location":"api/client/#httpr.Client.options","title":"options","text":"<pre><code>options(url: str, **kwargs: Unpack[RequestParams]) -&gt; Response\n</code></pre> <p>Make an OPTIONS request.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Request URL.</p> required <code>**kwargs</code> <code>Unpack[RequestParams]</code> <p>Request parameters (params, headers, cookies, auth, auth_bearer, timeout).</p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>Response object.</p> Example <pre><code>response = client.options(\"https://httpbin.org/get\")\nprint(response.headers.get(\"allow\"))\n</code></pre>"},{"location":"api/client/#httpr.Client.delete","title":"delete","text":"<pre><code>delete(url: str, **kwargs: Unpack[RequestParams]) -&gt; Response\n</code></pre> <p>Make a DELETE request.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Request URL.</p> required <code>**kwargs</code> <code>Unpack[RequestParams]</code> <p>Request parameters (params, headers, cookies, auth, auth_bearer, timeout).</p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>Response object.</p> Example <pre><code>response = client.delete(\"https://httpbin.org/delete\")\nprint(response.status_code)\n</code></pre>"},{"location":"api/client/#httpr.Client.post","title":"post","text":"<pre><code>post(url: str, **kwargs: Unpack[RequestParams]) -&gt; Response\n</code></pre> <p>Make a POST request.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Request URL.</p> required <code>**kwargs</code> <code>Unpack[RequestParams]</code> <p>Request parameters including body options.</p> <code>{}</code> <p>Other Parameters:</p> Name Type Description <code>params</code> <code>Optional[dict[str, str]]</code> <p>Query parameters.</p> <code>headers</code> <code>Optional[dict[str, str]]</code> <p>Request headers.</p> <code>cookies</code> <code>Optional[dict[str, str]]</code> <p>Request cookies.</p> <code>auth</code> <code>Optional[tuple[str, Optional[str]]]</code> <p>Basic auth credentials.</p> <code>auth_bearer</code> <code>Optional[str]</code> <p>Bearer token.</p> <code>timeout</code> <code>Optional[float]</code> <p>Request timeout.</p> <code>content</code> <code>Optional[bytes]</code> <p>Raw bytes body.</p> <code>data</code> <code>Optional[dict[str, Any]]</code> <p>Form-encoded body.</p> <code>json</code> <code>Optional[Any]</code> <p>JSON body.</p> <code>files</code> <code>Optional[dict[str, str]]</code> <p>Multipart file uploads.</p> <p>Returns:</p> Type Description <code>Response</code> <p>Response object.</p> Example <pre><code># JSON body\nresponse = client.post(\n    \"https://httpbin.org/post\",\n    json={\"name\": \"httpr\", \"fast\": True},\n)\n\n# Form data\nresponse = client.post(\n    \"https://httpbin.org/post\",\n    data={\"username\": \"user\", \"password\": \"pass\"},\n)\n\n# File upload\nresponse = client.post(\n    \"https://httpbin.org/post\",\n    files={\"document\": \"/path/to/file.pdf\"},\n)\n</code></pre>"},{"location":"api/client/#httpr.Client.put","title":"put","text":"<pre><code>put(url: str, **kwargs: Unpack[RequestParams]) -&gt; Response\n</code></pre> <p>Make a PUT request.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Request URL.</p> required <code>**kwargs</code> <code>Unpack[RequestParams]</code> <p>Request parameters including body options.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>Response object.</p> Example <pre><code>response = client.put(\n    \"https://httpbin.org/put\",\n    json={\"key\": \"updated_value\"},\n)\n</code></pre>"},{"location":"api/client/#httpr.Client.patch","title":"patch","text":"<pre><code>patch(url: str, **kwargs: Unpack[RequestParams]) -&gt; Response\n</code></pre> <p>Make a PATCH request.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Request URL.</p> required <code>**kwargs</code> <code>Unpack[RequestParams]</code> <p>Request parameters including body options.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>Response object.</p> Example <pre><code>response = client.patch(\n    \"https://httpbin.org/patch\",\n    json={\"field\": \"new_value\"},\n)\n</code></pre>"},{"location":"api/client/#httpr.Client.stream","title":"stream","text":"<pre><code>stream(method: HttpMethod, url: str, **kwargs: Unpack[RequestParams]) -&gt; Generator[StreamingResponse, None, None]\n</code></pre> <p>Make a streaming HTTP request.</p> <p>Returns a context manager that yields a StreamingResponse for iterating over the response body in chunks without buffering the entire response in memory.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>HttpMethod</code> <p>HTTP method (GET, POST, PUT, PATCH, DELETE, HEAD, OPTIONS).</p> required <code>url</code> <code>str</code> <p>Request URL.</p> required <code>**kwargs</code> <code>Unpack[RequestParams]</code> <p>Request parameters (same as request()).</p> <code>{}</code> <p>Yields:</p> Name Type Description <code>StreamingResponse</code> <code>StreamingResponse</code> <p>A response object that can be iterated to receive chunks.</p> Example <p>Basic streaming:</p> <pre><code>with client.stream(\"GET\", \"https://example.com/large-file\") as response:\n    for chunk in response.iter_bytes():\n        process(chunk)\n</code></pre> <p>Streaming text:</p> <pre><code>with client.stream(\"GET\", \"https://example.com/text\") as response:\n    for text in response.iter_text():\n        print(text, end=\"\")\n</code></pre> <p>Streaming lines (e.g., Server-Sent Events):</p> <pre><code>with client.stream(\"GET\", \"https://example.com/events\") as response:\n    for line in response.iter_lines():\n        print(line.strip())\n</code></pre> <p>Conditional reading:</p> <pre><code>with client.stream(\"GET\", url) as response:\n    if response.status_code == 200:\n        content = response.read()  # Read all remaining content\n    else:\n        pass  # Don't read the body\n</code></pre> Note <p>The response body is only read when you iterate over it or call read(). Always use this as a context manager to ensure proper cleanup.</p>"},{"location":"api/client/#httpr.Client.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the client and release resources.</p> Example <pre><code>client = httpr.Client()\ntry:\n    response = client.get(\"https://example.com\")\nfinally:\n    client.close()\n</code></pre>"},{"location":"api/functions/","title":"Module Functions","text":"<p>Convenience functions for making one-off HTTP requests.</p> <p>These functions create a temporary <code>Client</code> internally for each request. For multiple requests, use a <code>Client</code> instance for better performance.</p>"},{"location":"api/functions/#functions","title":"Functions","text":""},{"location":"api/functions/#httpr.request","title":"request","text":"<pre><code>request(method: HttpMethod, url: str, verify: bool | None = True, ca_cert_file: str | None = None, client_pem: str | None = None, **kwargs: Unpack[RequestParams]) -&gt; Response\n</code></pre> <p>Make an HTTP request using a temporary client.</p> <p>This is a convenience function for one-off requests. For multiple requests, use a Client instance for better performance (connection pooling).</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>HttpMethod</code> <p>HTTP method (GET, POST, PUT, PATCH, DELETE, HEAD, OPTIONS).</p> required <code>url</code> <code>str</code> <p>Request URL.</p> required <code>verify</code> <code>bool | None</code> <p>Verify SSL certificates. Default is True.</p> <code>True</code> <code>ca_cert_file</code> <code>str | None</code> <p>Path to CA certificate bundle.</p> <code>None</code> <code>client_pem</code> <code>str | None</code> <p>Path to client certificate for mTLS.</p> <code>None</code> <code>**kwargs</code> <code>Unpack[RequestParams]</code> <p>Additional request parameters.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>Response object.</p> Example <pre><code>import httpr\n\nresponse = httpr.request(\"GET\", \"https://httpbin.org/get\")\nresponse = httpr.request(\"POST\", \"https://httpbin.org/post\", json={\"key\": \"value\"})\n</code></pre>"},{"location":"api/functions/#httpr.get","title":"get","text":"<pre><code>get(url: str, **kwargs: Unpack[ClientRequestParams]) -&gt; Response\n</code></pre> <p>Make a GET request using a temporary client.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Request URL.</p> required <code>**kwargs</code> <code>Unpack[ClientRequestParams]</code> <p>Request parameters (params, headers, cookies, auth, timeout, etc.).</p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>Response object.</p> Example <pre><code>import httpr\n\nresponse = httpr.get(\"https://httpbin.org/get\", params={\"key\": \"value\"})\nprint(response.json())\n</code></pre>"},{"location":"api/functions/#httpr.post","title":"post","text":"<pre><code>post(url: str, **kwargs: Unpack[ClientRequestParams]) -&gt; Response\n</code></pre> <p>Make a POST request using a temporary client.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Request URL.</p> required <code>**kwargs</code> <code>Unpack[ClientRequestParams]</code> <p>Request parameters (json, data, content, files, etc.).</p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>Response object.</p> Example <pre><code>import httpr\n\n# JSON body\nresponse = httpr.post(\"https://httpbin.org/post\", json={\"key\": \"value\"})\n\n# Form data\nresponse = httpr.post(\"https://httpbin.org/post\", data={\"field\": \"value\"})\n</code></pre>"},{"location":"api/functions/#httpr.put","title":"put","text":"<pre><code>put(url: str, **kwargs: Unpack[ClientRequestParams]) -&gt; Response\n</code></pre> <p>Make a PUT request using a temporary client.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Request URL.</p> required <code>**kwargs</code> <code>Unpack[ClientRequestParams]</code> <p>Request parameters.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>Response object.</p> Example <pre><code>import httpr\n\nresponse = httpr.put(\"https://httpbin.org/put\", json={\"key\": \"value\"})\n</code></pre>"},{"location":"api/functions/#httpr.patch","title":"patch","text":"<pre><code>patch(url: str, **kwargs: Unpack[ClientRequestParams]) -&gt; Response\n</code></pre> <p>Make a PATCH request using a temporary client.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Request URL.</p> required <code>**kwargs</code> <code>Unpack[ClientRequestParams]</code> <p>Request parameters.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>Response object.</p> Example <pre><code>import httpr\n\nresponse = httpr.patch(\"https://httpbin.org/patch\", json={\"field\": \"new_value\"})\n</code></pre>"},{"location":"api/functions/#httpr.delete","title":"delete","text":"<pre><code>delete(url: str, **kwargs: Unpack[ClientRequestParams]) -&gt; Response\n</code></pre> <p>Make a DELETE request using a temporary client.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Request URL.</p> required <code>**kwargs</code> <code>Unpack[ClientRequestParams]</code> <p>Request parameters.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>Response object.</p> Example <pre><code>import httpr\n\nresponse = httpr.delete(\"https://httpbin.org/delete\")\n</code></pre>"},{"location":"api/functions/#httpr.head","title":"head","text":"<pre><code>head(url: str, **kwargs: Unpack[ClientRequestParams]) -&gt; Response\n</code></pre> <p>Make a HEAD request using a temporary client.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Request URL.</p> required <code>**kwargs</code> <code>Unpack[ClientRequestParams]</code> <p>Request parameters.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>Response object (body will be empty).</p> Example <pre><code>import httpr\n\nresponse = httpr.head(\"https://httpbin.org/get\")\nprint(response.headers)\n</code></pre>"},{"location":"api/functions/#httpr.options","title":"options","text":"<pre><code>options(url: str, **kwargs: Unpack[ClientRequestParams]) -&gt; Response\n</code></pre> <p>Make an OPTIONS request using a temporary client.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Request URL.</p> required <code>**kwargs</code> <code>Unpack[ClientRequestParams]</code> <p>Request parameters.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>Response object.</p> Example <pre><code>import httpr\n\nresponse = httpr.options(\"https://httpbin.org/get\")\n</code></pre>"},{"location":"api/response/","title":"Response","text":"<p>The HTTP response object returned by all request methods.</p>"},{"location":"api/response/#overview","title":"Overview","text":"<p>The <code>Response</code> class provides access to all aspects of an HTTP response:</p> <pre><code>import httpr\n\nresponse = httpr.get(\"https://httpbin.org/get\")\n\n# Status\nprint(response.status_code)  # 200\n\n# Body\nprint(response.text)         # Decoded text\nprint(response.content)      # Raw bytes\ndata = response.json()       # Parsed JSON\n\n# Headers (case-insensitive)\nprint(response.headers[\"content-type\"])\nprint(response.headers[\"Content-Type\"])  # Same result\n\n# Cookies\nprint(response.cookies)      # {\"session\": \"value\"}\n\n# Metadata\nprint(response.url)          # Final URL after redirects\nprint(response.encoding)     # Detected encoding\n</code></pre>"},{"location":"api/response/#properties","title":"Properties","text":""},{"location":"api/response/#status_code","title":"status_code","text":"<pre><code>@property\ndef status_code(self) -&gt; int\n</code></pre> <p>HTTP status code (e.g., 200, 404, 500).</p> <p>Example: <pre><code>response = httpr.get(\"https://httpbin.org/status/201\")\nprint(response.status_code)  # 201\n</code></pre></p>"},{"location":"api/response/#text","title":"text","text":"<pre><code>@property\ndef text(self) -&gt; str\n</code></pre> <p>Response body decoded as text.</p> <p>Encoding is automatically detected from:</p> <ol> <li><code>Content-Type</code> header charset</li> <li>HTML meta charset tag</li> <li>Falls back to UTF-8</li> </ol> <p>Example: <pre><code>response = httpr.get(\"https://httpbin.org/html\")\nprint(response.text)  # HTML content\n</code></pre></p>"},{"location":"api/response/#content","title":"content","text":"<pre><code>@property\ndef content(self) -&gt; bytes\n</code></pre> <p>Response body as raw bytes.</p> <p>Example: <pre><code>response = httpr.get(\"https://httpbin.org/bytes/100\")\nprint(len(response.content))  # 100\n\n# Save binary file\nresponse = httpr.get(\"https://httpbin.org/image/png\")\nwith open(\"image.png\", \"wb\") as f:\n    f.write(response.content)\n</code></pre></p>"},{"location":"api/response/#headers","title":"headers","text":"<pre><code>@property\ndef headers(self) -&gt; CaseInsensitiveHeaderMap\n</code></pre> <p>Response headers as a case-insensitive dict-like object.</p> <p>Supports:</p> <ul> <li><code>response.headers[\"Content-Type\"]</code> - get by key</li> <li><code>response.headers.get(\"content-type\", \"default\")</code> - get with default</li> <li><code>\"content-type\" in response.headers</code> - check existence</li> <li><code>response.headers.keys()</code> - all header names</li> <li><code>response.headers.values()</code> - all header values</li> <li><code>response.headers.items()</code> - key-value pairs</li> </ul> <p>Example: <pre><code>response = httpr.get(\"https://httpbin.org/get\")\n\n# Case-insensitive access\nprint(response.headers[\"content-type\"])\nprint(response.headers[\"Content-Type\"])  # Same\n\n# Iteration\nfor name, value in response.headers.items():\n    print(f\"{name}: {value}\")\n</code></pre></p>"},{"location":"api/response/#cookies","title":"cookies","text":"<pre><code>@property\ndef cookies(self) -&gt; dict[str, str]\n</code></pre> <p>Cookies set by the server via <code>Set-Cookie</code> headers.</p> <p>Example: <pre><code>response = httpr.get(\"https://httpbin.org/cookies/set?name=value\")\nprint(response.cookies)  # {\"name\": \"value\"}\n</code></pre></p>"},{"location":"api/response/#url","title":"url","text":"<pre><code>@property\ndef url(self) -&gt; str\n</code></pre> <p>Final URL after following any redirects.</p> <p>Example: <pre><code>response = httpr.get(\"https://httpbin.org/redirect/3\")\nprint(response.url)  # https://httpbin.org/get\n</code></pre></p>"},{"location":"api/response/#encoding","title":"encoding","text":"<pre><code>@property\ndef encoding(self) -&gt; str\n</code></pre> <p>Character encoding detected from response headers or content.</p> <p>Example: <pre><code>response = httpr.get(\"https://httpbin.org/encoding/utf8\")\nprint(response.encoding)  # \"utf-8\"\n</code></pre></p>"},{"location":"api/response/#text_markdown","title":"text_markdown","text":"<pre><code>@property\ndef text_markdown(self) -&gt; str\n</code></pre> <p>HTML response body converted to Markdown format.</p> <p>Uses Rust's <code>html2text</code> crate for conversion.</p> <p>Example: <pre><code>response = httpr.get(\"https://example.com\")\nprint(response.text_markdown)\n# # Example Domain\n#\n# This domain is for use in illustrative examples...\n</code></pre></p>"},{"location":"api/response/#text_plain","title":"text_plain","text":"<pre><code>@property\ndef text_plain(self) -&gt; str\n</code></pre> <p>HTML response body converted to plain text (no formatting).</p> <p>Example: <pre><code>response = httpr.get(\"https://example.com\")\nprint(response.text_plain)\n</code></pre></p>"},{"location":"api/response/#text_rich","title":"text_rich","text":"<pre><code>@property\ndef text_rich(self) -&gt; str\n</code></pre> <p>HTML response body converted to rich text format.</p>"},{"location":"api/response/#methods","title":"Methods","text":""},{"location":"api/response/#json","title":"json","text":"<pre><code>def json(self) -&gt; Any\n</code></pre> <p>Parse response body as JSON.</p> <p>Returns: Parsed JSON (dict, list, str, int, float, bool, or None)</p> <p>Raises: Exception if body is not valid JSON</p> <p>Example: <pre><code>response = httpr.get(\"https://httpbin.org/json\")\ndata = response.json()\nprint(data[\"slideshow\"][\"title\"])\n</code></pre></p> <p>Note</p> <p><code>json()</code> is a method, not a property. Call it with parentheses.</p>"},{"location":"api/response/#streamingresponse","title":"StreamingResponse","text":"<p>For streaming large responses without buffering the entire response in memory, use the <code>Client.stream()</code> method which returns a <code>StreamingResponse</code>.</p> <pre><code>import httpr\n\nwith httpr.Client() as client:\n    with client.stream(\"GET\", \"https://httpbin.org/stream-bytes/1000\") as response:\n        for chunk in response.iter_bytes():\n            process(chunk)\n</code></pre>"},{"location":"api/response/#properties_1","title":"Properties","text":""},{"location":"api/response/#status_code_1","title":"status_code","text":"<pre><code>@property\ndef status_code(self) -&gt; int\n</code></pre> <p>HTTP status code (e.g., 200, 404, 500).</p> <p>Example: <pre><code>with client.stream(\"GET\", \"https://httpbin.org/get\") as response:\n    print(response.status_code)  # 200\n</code></pre></p>"},{"location":"api/response/#headers_1","title":"headers","text":"<pre><code>@property\ndef headers(self) -&gt; CaseInsensitiveHeaderMap\n</code></pre> <p>Response headers as a case-insensitive dict-like object.</p> <p>Example: <pre><code>with client.stream(\"GET\", \"https://httpbin.org/get\") as response:\n    content_type = response.headers[\"content-type\"]\n</code></pre></p>"},{"location":"api/response/#cookies_1","title":"cookies","text":"<pre><code>@property\ndef cookies(self) -&gt; dict[str, str]\n</code></pre> <p>Cookies set by the server via <code>Set-Cookie</code> headers.</p>"},{"location":"api/response/#url_1","title":"url","text":"<pre><code>@property\ndef url(self) -&gt; str\n</code></pre> <p>Final URL after following any redirects.</p>"},{"location":"api/response/#is_closed","title":"is_closed","text":"<pre><code>@property\ndef is_closed(self) -&gt; bool\n</code></pre> <p>Whether the stream has been closed.</p> <p>Example: <pre><code>with client.stream(\"GET\", \"https://httpbin.org/get\") as response:\n    print(response.is_closed)  # False\nprint(response.is_closed)  # True (after context manager exits)\n</code></pre></p>"},{"location":"api/response/#is_consumed","title":"is_consumed","text":"<pre><code>@property\ndef is_consumed(self) -&gt; bool\n</code></pre> <p>Whether the stream has been fully consumed.</p> <p>Example: <pre><code>with client.stream(\"GET\", \"https://httpbin.org/get\") as response:\n    print(response.is_consumed)  # False\n    _ = list(response)  # Consume the stream\n    print(response.is_consumed)  # True\n</code></pre></p>"},{"location":"api/response/#methods_1","title":"Methods","text":""},{"location":"api/response/#iter_bytes","title":"iter_bytes","text":"<pre><code>def iter_bytes(self) -&gt; Iterator[bytes]\n</code></pre> <p>Iterate over the response body as bytes chunks.</p> <p>Returns: Iterator yielding bytes chunks</p> <p>Example: <pre><code>with client.stream(\"GET\", \"https://httpbin.org/stream-bytes/1000\") as response:\n    for chunk in response.iter_bytes():\n        print(f\"Received {len(chunk)} bytes\")\n</code></pre></p>"},{"location":"api/response/#iter_text","title":"iter_text","text":"<pre><code>def iter_text(self) -&gt; TextIterator\n</code></pre> <p>Iterate over the response body as text chunks, decoded using the response encoding.</p> <p>Returns: TextIterator yielding string chunks</p> <p>Example: <pre><code>with client.stream(\"GET\", \"https://httpbin.org/html\") as response:\n    for text in response.iter_text():\n        print(text, end=\"\")\n</code></pre></p>"},{"location":"api/response/#iter_lines","title":"iter_lines","text":"<pre><code>def iter_lines(self) -&gt; LineIterator\n</code></pre> <p>Iterate over the response body line by line.</p> <p>Returns: LineIterator yielding string lines</p> <p>Useful for Server-Sent Events (SSE) and line-based protocols.</p> <p>Example: <pre><code>with client.stream(\"GET\", \"https://httpbin.org/stream/10\") as response:\n    for line in response.iter_lines():\n        print(line.strip())\n</code></pre></p>"},{"location":"api/response/#read","title":"read","text":"<pre><code>def read(self) -&gt; bytes\n</code></pre> <p>Read the entire remaining response body into memory.</p> <p>Returns: Response body as bytes</p> <p>Example: <pre><code>with client.stream(\"GET\", \"https://httpbin.org/get\") as response:\n    if response.status_code == 200:\n        content = response.read()\n</code></pre></p>"},{"location":"api/response/#close","title":"close","text":"<pre><code>def close(self) -&gt; None\n</code></pre> <p>Close the stream and release resources.</p> <p>Note: When using the context manager, <code>close()</code> is called automatically.</p> <p>Example: <pre><code>with client.stream(\"GET\", \"https://httpbin.org/get\") as response:\n    # Process headers\n    if response.status_code != 200:\n        response.close()  # Close early without reading body\n        return\n    # Otherwise read body\n    content = response.read()\n</code></pre></p>"},{"location":"api/response/#direct-iteration","title":"Direct Iteration","text":"<p><code>StreamingResponse</code> supports direct iteration, which is equivalent to calling <code>iter_bytes()</code>:</p> <pre><code>with client.stream(\"GET\", \"https://httpbin.org/stream-bytes/1000\") as response:\n    for chunk in response:  # Same as response.iter_bytes()\n        process(chunk)\n</code></pre>"},{"location":"api/response/#important-notes","title":"Important Notes","text":"<ul> <li>Always use as context manager: Ensures proper cleanup of resources</li> <li>Headers available immediately: Status code, headers, cookies, and URL are accessible before reading the body</li> <li>Body only read on demand: The response body is only fetched when you iterate or call <code>read()</code></li> <li>Cannot re-read: Once consumed, the stream cannot be read again</li> <li>Supported for all methods: GET, POST, PUT, PATCH, DELETE, HEAD, OPTIONS</li> </ul>"},{"location":"api/response/#exception-handling","title":"Exception Handling","text":"<p>The streaming response raises specific exceptions:</p> <ul> <li><code>StreamClosed</code>: Raised when attempting to read from a closed stream</li> <li><code>StreamConsumed</code>: Raised when attempting to re-read a consumed stream</li> </ul> <p>Example: <pre><code>import httpr\n\nwith client.stream(\"GET\", \"https://httpbin.org/get\") as response:\n    content = response.read()\n\n    # This will raise StreamConsumed\n    try:\n        more = response.read()\n    except httpr.StreamConsumed:\n        print(\"Stream already consumed\")\n</code></pre></p>"},{"location":"tutorial/","title":"Tutorial","text":"<p>Welcome to the httpr tutorial! This guide will take you through all the features of httpr step by step.</p>"},{"location":"tutorial/#what-youll-learn","title":"What You'll Learn","text":"<p>This tutorial is organized into sections that build on each other:</p> <ul> <li> <p> Making Requests</p> <p>Learn how to make HTTP requests with different methods, headers, and data.</p> <p> Making Requests</p> </li> <li> <p> Response Handling</p> <p>Work with response data, headers, cookies, and status codes.</p> <p> Response Handling</p> </li> <li> <p> Authentication</p> <p>Use Basic Auth, Bearer tokens, and other authentication methods.</p> <p> Authentication</p> </li> <li> <p> Async Client</p> <p>Use async/await for concurrent requests.</p> <p> Async Client</p> </li> </ul>"},{"location":"tutorial/#prerequisites","title":"Prerequisites","text":"<p>Before starting, make sure you have httpr installed:</p> <pre><code>uv add httpr\n# or\npip install httpr\n</code></pre> <p>Verify the installation:</p> <pre><code>import httpr\nprint(httpr.__version__ if hasattr(httpr, '__version__') else \"httpr installed!\")\n</code></pre>"},{"location":"tutorial/#module-level-functions-vs-client","title":"Module-Level Functions vs Client","text":"<p>httpr provides two ways to make requests:</p>"},{"location":"tutorial/#module-level-functions","title":"Module-Level Functions","text":"<p>For quick, one-off requests:</p> <pre><code>import httpr\n\nresponse = httpr.get(\"https://httpbin.org/get\")\n</code></pre> <p>Each call creates a new client internally, which is convenient but not efficient for multiple requests.</p>"},{"location":"tutorial/#client-instance","title":"Client Instance","text":"<p>For applications making multiple requests:</p> <pre><code>import httpr\n\nwith httpr.Client() as client:\n    response1 = client.get(\"https://httpbin.org/get\")\n    response2 = client.get(\"https://httpbin.org/ip\")\n</code></pre> <p>Benefits of using a <code>Client</code>:</p> <ul> <li>Connection pooling: Reuses connections for better performance</li> <li>Default configuration: Set headers, auth, timeout once</li> <li>Cookie persistence: Cookies are automatically stored and sent</li> <li>Resource management: Proper cleanup with context manager</li> </ul>"},{"location":"tutorial/#next-steps","title":"Next Steps","text":"<p>Start with Making Requests to learn the basics of sending HTTP requests.</p>"},{"location":"tutorial/async/","title":"Async Client","text":"<p>httpr provides an <code>AsyncClient</code> for use with Python's <code>asyncio</code>. This allows you to make concurrent HTTP requests efficiently.</p>"},{"location":"tutorial/async/#basic-usage","title":"Basic Usage","text":"<p>Use <code>AsyncClient</code> with <code>async</code>/<code>await</code> syntax:</p> <pre><code>import asyncio\nimport httpr\n\nasync def main():\n    async with httpr.AsyncClient() as client:\n        response = await client.get(\"https://httpbin.org/get\")\n        print(response.json())\n\nasyncio.run(main())\n</code></pre>"},{"location":"tutorial/async/#creating-an-asyncclient","title":"Creating an AsyncClient","text":"<p><code>AsyncClient</code> accepts all the same parameters as <code>Client</code>:</p> <pre><code>import httpr\n\nclient = httpr.AsyncClient(\n    auth=(\"user\", \"password\"),\n    auth_bearer=\"token\",\n    headers={\"User-Agent\": \"my-app/1.0\"},\n    cookies={\"session\": \"abc123\"},\n    timeout=30,\n    follow_redirects=True,\n    max_redirects=10,\n    verify=True,\n    ca_cert_file=\"/path/to/ca-bundle.pem\",\n    proxy=\"http://proxy:8080\",\n)\n</code></pre>"},{"location":"tutorial/async/#context-manager","title":"Context Manager","text":"<p>Always use the async context manager to ensure proper cleanup:</p> <pre><code>import asyncio\nimport httpr\n\nasync def main():\n    async with httpr.AsyncClient() as client:\n        response = await client.get(\"https://httpbin.org/get\")\n        print(response.status_code)\n    # Client is automatically closed\n\nasyncio.run(main())\n</code></pre> <p>Or manually close the client:</p> <pre><code>import asyncio\nimport httpr\n\nasync def main():\n    client = httpr.AsyncClient()\n    try:\n        response = await client.get(\"https://httpbin.org/get\")\n        print(response.status_code)\n    finally:\n        await client.aclose()\n\nasyncio.run(main())\n</code></pre>"},{"location":"tutorial/async/#http-methods","title":"HTTP Methods","text":"<p>All HTTP methods are available as async:</p> <pre><code>import asyncio\nimport httpr\n\nasync def main():\n    async with httpr.AsyncClient() as client:\n        # GET\n        response = await client.get(\"https://httpbin.org/get\")\n\n        # POST\n        response = await client.post(\n            \"https://httpbin.org/post\",\n            json={\"key\": \"value\"}\n        )\n\n        # PUT\n        response = await client.put(\n            \"https://httpbin.org/put\",\n            json={\"key\": \"value\"}\n        )\n\n        # PATCH\n        response = await client.patch(\n            \"https://httpbin.org/patch\",\n            json={\"key\": \"value\"}\n        )\n\n        # DELETE\n        response = await client.delete(\"https://httpbin.org/delete\")\n\n        # HEAD\n        response = await client.head(\"https://httpbin.org/get\")\n\n        # OPTIONS\n        response = await client.options(\"https://httpbin.org/get\")\n\n        # Generic request\n        response = await client.request(\"GET\", \"https://httpbin.org/get\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"tutorial/async/#concurrent-requests","title":"Concurrent Requests","text":"<p>The main benefit of <code>AsyncClient</code> is making multiple requests concurrently:</p>"},{"location":"tutorial/async/#using-asynciogather","title":"Using asyncio.gather","text":"<pre><code>import asyncio\nimport httpr\n\nasync def fetch_url(client: httpr.AsyncClient, url: str) -&gt; dict:\n    response = await client.get(url)\n    return {\"url\": url, \"status\": response.status_code}\n\nasync def main():\n    urls = [\n        \"https://httpbin.org/get\",\n        \"https://httpbin.org/ip\",\n        \"https://httpbin.org/user-agent\",\n        \"https://httpbin.org/headers\",\n    ]\n\n    async with httpr.AsyncClient() as client:\n        # Fetch all URLs concurrently\n        tasks = [fetch_url(client, url) for url in urls]\n        results = await asyncio.gather(*tasks)\n\n        for result in results:\n            print(f\"{result['url']}: {result['status']}\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"tutorial/async/#using-asyncioas_completed","title":"Using asyncio.as_completed","text":"<p>Process results as they complete:</p> <pre><code>import asyncio\nimport httpr\n\nasync def fetch_url(client: httpr.AsyncClient, url: str) -&gt; dict:\n    response = await client.get(url)\n    return {\"url\": url, \"status\": response.status_code, \"data\": response.json()}\n\nasync def main():\n    urls = [\n        \"https://httpbin.org/delay/2\",\n        \"https://httpbin.org/delay/1\",\n        \"https://httpbin.org/get\",\n    ]\n\n    async with httpr.AsyncClient() as client:\n        tasks = [fetch_url(client, url) for url in urls]\n\n        # Process results as they complete (fastest first)\n        for coro in asyncio.as_completed(tasks):\n            result = await coro\n            print(f\"Completed: {result['url']}\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"tutorial/async/#with-semaphore-rate-limiting","title":"With Semaphore (Rate Limiting)","text":"<p>Limit concurrent requests to avoid overwhelming servers:</p> <pre><code>import asyncio\nimport httpr\n\nasync def fetch_with_limit(\n    client: httpr.AsyncClient,\n    url: str,\n    semaphore: asyncio.Semaphore\n) -&gt; dict:\n    async with semaphore:  # Limit concurrent requests\n        response = await client.get(url)\n        return {\"url\": url, \"status\": response.status_code}\n\nasync def main():\n    urls = [f\"https://httpbin.org/get?id={i}\" for i in range(20)]\n\n    # Allow max 5 concurrent requests\n    semaphore = asyncio.Semaphore(5)\n\n    async with httpr.AsyncClient() as client:\n        tasks = [fetch_with_limit(client, url, semaphore) for url in urls]\n        results = await asyncio.gather(*tasks)\n\n        print(f\"Fetched {len(results)} URLs\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"tutorial/async/#error-handling","title":"Error Handling","text":"<p>Handle errors in async code:</p> <pre><code>import asyncio\nimport httpr\n\nasync def safe_fetch(client: httpr.AsyncClient, url: str) -&gt; dict | None:\n    try:\n        response = await client.get(url, timeout=5)\n        return {\"url\": url, \"status\": response.status_code, \"data\": response.json()}\n    except Exception as e:\n        print(f\"Error fetching {url}: {e}\")\n        return None\n\nasync def main():\n    urls = [\n        \"https://httpbin.org/get\",\n        \"https://httpbin.org/delay/10\",  # Will timeout\n        \"https://invalid.url.example\",    # Will fail\n    ]\n\n    async with httpr.AsyncClient(timeout=2) as client:\n        tasks = [safe_fetch(client, url) for url in urls]\n        results = await asyncio.gather(*tasks)\n\n        successful = [r for r in results if r is not None]\n        print(f\"Successful: {len(successful)}/{len(urls)}\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"tutorial/async/#real-world-example-api-aggregator","title":"Real-World Example: API Aggregator","text":"<pre><code>import asyncio\nimport httpr\n\nclass ApiAggregator:\n    \"\"\"Fetch data from multiple APIs concurrently.\"\"\"\n\n    def __init__(self, timeout: float = 10):\n        self.client = httpr.AsyncClient(timeout=timeout)\n\n    async def __aenter__(self):\n        return self\n\n    async def __aexit__(self, *args):\n        await self.client.aclose()\n\n    async def fetch_user(self, user_id: int) -&gt; dict:\n        \"\"\"Fetch user from API.\"\"\"\n        response = await self.client.get(\n            f\"https://jsonplaceholder.typicode.com/users/{user_id}\"\n        )\n        return response.json()\n\n    async def fetch_posts(self, user_id: int) -&gt; list:\n        \"\"\"Fetch posts for a user.\"\"\"\n        response = await self.client.get(\n            \"https://jsonplaceholder.typicode.com/posts\",\n            params={\"userId\": user_id}\n        )\n        return response.json()\n\n    async def fetch_user_with_posts(self, user_id: int) -&gt; dict:\n        \"\"\"Fetch user and their posts concurrently.\"\"\"\n        user, posts = await asyncio.gather(\n            self.fetch_user(user_id),\n            self.fetch_posts(user_id)\n        )\n        return {\"user\": user, \"posts\": posts}\n\nasync def main():\n    async with ApiAggregator() as api:\n        # Fetch data for multiple users concurrently\n        user_ids = [1, 2, 3]\n        tasks = [api.fetch_user_with_posts(uid) for uid in user_ids]\n        results = await asyncio.gather(*tasks)\n\n        for result in results:\n            user = result[\"user\"]\n            posts = result[\"posts\"]\n            print(f\"{user['name']}: {len(posts)} posts\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"tutorial/async/#implementation-note","title":"Implementation Note","text":"<p>How AsyncClient Works</p> <p><code>AsyncClient</code> wraps the synchronous Rust client using <code>asyncio.run_in_executor()</code>. This means:</p> <ul> <li>Requests run in a thread pool, not native async I/O</li> <li>Still provides concurrency benefits for I/O-bound tasks</li> <li>Compatible with asyncio event loops</li> <li>Same performance as sync client for individual requests</li> </ul> <p>This design keeps the implementation simple while providing async compatibility.</p>"},{"location":"tutorial/async/#comparison-sync-vs-async","title":"Comparison: Sync vs Async","text":"<pre><code>import time\nimport asyncio\nimport httpr\n\n# Synchronous - sequential requests\ndef sync_fetch():\n    with httpr.Client() as client:\n        for i in range(5):\n            client.get(f\"https://httpbin.org/delay/1\")\n\n# Asynchronous - concurrent requests\nasync def async_fetch():\n    async with httpr.AsyncClient() as client:\n        tasks = [\n            client.get(f\"https://httpbin.org/delay/1\")\n            for i in range(5)\n        ]\n        await asyncio.gather(*tasks)\n\n# Sync: ~5 seconds (sequential)\nstart = time.time()\nsync_fetch()\nprint(f\"Sync: {time.time() - start:.2f}s\")\n\n# Async: ~1 second (concurrent)\nstart = time.time()\nasyncio.run(async_fetch())\nprint(f\"Async: {time.time() - start:.2f}s\")\n</code></pre>"},{"location":"tutorial/async/#next-steps","title":"Next Steps","text":"<ul> <li>SSL/TLS - Secure connections with async</li> <li>Proxy Configuration - Use proxies with AsyncClient</li> <li>API Reference - Complete AsyncClient API</li> </ul>"},{"location":"tutorial/authentication/","title":"Authentication","text":"<p>httpr supports multiple authentication methods for securing your HTTP requests.</p>"},{"location":"tutorial/authentication/#basic-authentication","title":"Basic Authentication","text":"<p>HTTP Basic Authentication sends username and password encoded in the request header.</p>"},{"location":"tutorial/authentication/#per-request-authentication","title":"Per-Request Authentication","text":"<pre><code>import httpr\n\nresponse = httpr.get(\n    \"https://httpbin.org/basic-auth/user/pass\",\n    auth=(\"user\", \"pass\")\n)\nprint(response.status_code)  # 200\n</code></pre>"},{"location":"tutorial/authentication/#client-default-authentication","title":"Client Default Authentication","text":"<p>Set authentication for all requests from a client:</p> <pre><code>import httpr\n\nclient = httpr.Client(auth=(\"username\", \"password\"))\n\n# All requests include Basic Auth header\nresponse = client.get(\"https://api.example.com/protected\")\nresponse = client.get(\"https://api.example.com/another-endpoint\")\n</code></pre>"},{"location":"tutorial/authentication/#password-less-basic-auth","title":"Password-less Basic Auth","text":"<p>Some APIs require only a username (API key) without a password:</p> <pre><code>import httpr\n\n# Password can be None\nresponse = httpr.get(\n    \"https://api.example.com/data\",\n    auth=(\"api_key_here\", None)\n)\n</code></pre>"},{"location":"tutorial/authentication/#how-it-works","title":"How It Works","text":"<p>Basic auth creates an <code>Authorization</code> header with base64-encoded credentials:</p> <pre><code>import httpr\n\nresponse = httpr.get(\n    \"https://httpbin.org/headers\",\n    auth=(\"user\", \"password\")\n)\n\n# The Authorization header is automatically set\nauth_header = response.json()[\"headers\"][\"Authorization\"]\nprint(auth_header)  # \"Basic dXNlcjpwYXNzd29yZA==\"\n</code></pre>"},{"location":"tutorial/authentication/#bearer-token-authentication","title":"Bearer Token Authentication","text":"<p>Bearer tokens are commonly used for OAuth 2.0 and API authentication.</p>"},{"location":"tutorial/authentication/#per-request-bearer-token","title":"Per-Request Bearer Token","text":"<pre><code>import httpr\n\nresponse = httpr.get(\n    \"https://api.example.com/data\",\n    auth_bearer=\"your-token-here\"\n)\n</code></pre>"},{"location":"tutorial/authentication/#client-default-bearer-token","title":"Client Default Bearer Token","text":"<pre><code>import httpr\n\nclient = httpr.Client(auth_bearer=\"your-api-token\")\n\n# All requests include the Bearer token\nresponse = client.get(\"https://api.example.com/users\")\nresponse = client.get(\"https://api.example.com/posts\")\n</code></pre>"},{"location":"tutorial/authentication/#how-it-works_1","title":"How It Works","text":"<p>Bearer auth creates an <code>Authorization: Bearer &lt;token&gt;</code> header:</p> <pre><code>import httpr\n\nresponse = httpr.get(\n    \"https://httpbin.org/headers\",\n    auth_bearer=\"my-secret-token\"\n)\n\nauth_header = response.json()[\"headers\"][\"Authorization\"]\nprint(auth_header)  # \"Bearer my-secret-token\"\n</code></pre>"},{"location":"tutorial/authentication/#custom-authentication-headers","title":"Custom Authentication Headers","text":"<p>For APIs that use non-standard authentication headers:</p> <pre><code>import httpr\n\n# API key in custom header\nresponse = httpr.get(\n    \"https://api.example.com/data\",\n    headers={\"X-API-Key\": \"your-api-key\"}\n)\n\n# Multiple auth headers\nclient = httpr.Client(\n    headers={\n        \"X-API-Key\": \"key123\",\n        \"X-API-Secret\": \"secret456\"\n    }\n)\n</code></pre>"},{"location":"tutorial/authentication/#updating-authentication","title":"Updating Authentication","text":"<p>You can update client authentication after creation:</p> <pre><code>import httpr\n\nclient = httpr.Client()\n\n# Set auth via property\nclient.auth = (\"new-user\", \"new-pass\")\nprint(client.auth)  # (\"new-user\", \"new-pass\")\n\n# Or use headers directly for bearer tokens\nclient.headers = {\"Authorization\": \"Bearer new-token\"}\n</code></pre>"},{"location":"tutorial/authentication/#authentication-patterns","title":"Authentication Patterns","text":""},{"location":"tutorial/authentication/#api-with-token-refresh","title":"API with Token Refresh","text":"<pre><code>import httpr\n\nclass ApiClient:\n    def __init__(self, token: str):\n        self.client = httpr.Client(auth_bearer=token)\n\n    def refresh_token(self, new_token: str):\n        \"\"\"Update the bearer token.\"\"\"\n        self.client = httpr.Client(auth_bearer=new_token)\n\n    def get_users(self):\n        return self.client.get(\"https://api.example.com/users\").json()\n\n# Usage\napi = ApiClient(\"initial-token\")\nusers = api.get_users()\n\n# When token expires\napi.refresh_token(\"refreshed-token\")\nusers = api.get_users()\n</code></pre>"},{"location":"tutorial/authentication/#environment-based-auth","title":"Environment-Based Auth","text":"<pre><code>import os\nimport httpr\n\n# Load credentials from environment\napi_token = os.environ.get(\"API_TOKEN\")\nif not api_token:\n    raise ValueError(\"API_TOKEN environment variable required\")\n\nclient = httpr.Client(auth_bearer=api_token)\n</code></pre>"},{"location":"tutorial/authentication/#different-auth-per-endpoint","title":"Different Auth per Endpoint","text":"<pre><code>import httpr\n\n# Public API - no auth\npublic_client = httpr.Client()\npublic_data = public_client.get(\"https://api.example.com/public\").json()\n\n# Authenticated API\nauth_client = httpr.Client(auth_bearer=\"secret-token\")\nprivate_data = auth_client.get(\"https://api.example.com/private\").json()\n</code></pre>"},{"location":"tutorial/authentication/#mtls-authentication","title":"mTLS Authentication","text":"<p>For mutual TLS (client certificate authentication), see the SSL/TLS Guide.</p> <pre><code>import httpr\n\n# Client certificate authentication\nclient = httpr.Client(\n    client_pem=\"/path/to/client-cert.pem\",\n    ca_cert_file=\"/path/to/ca-bundle.pem\"\n)\n</code></pre>"},{"location":"tutorial/authentication/#security-best-practices","title":"Security Best Practices","text":"<p>Security Tips</p> <ol> <li>Never hardcode credentials in source code</li> <li>Use environment variables or secure vaults for secrets</li> <li>Use HTTPS for all authenticated requests</li> <li>Rotate tokens regularly</li> <li>Use short-lived tokens when possible</li> </ol> <pre><code>import os\nimport httpr\n\n# Good: Load from environment\nclient = httpr.Client(\n    auth_bearer=os.environ[\"API_TOKEN\"],\n    https_only=True  # Enforce HTTPS\n)\n\n# Bad: Hardcoded credentials (don't do this!)\n# client = httpr.Client(auth=(\"admin\", \"password123\"))\n</code></pre>"},{"location":"tutorial/authentication/#complete-example","title":"Complete Example","text":"<pre><code>import os\nimport httpr\n\ndef create_api_client() -&gt; httpr.Client:\n    \"\"\"Create an authenticated API client.\"\"\"\n\n    # Get token from environment\n    token = os.environ.get(\"GITHUB_TOKEN\")\n    if not token:\n        raise ValueError(\"GITHUB_TOKEN not set\")\n\n    return httpr.Client(\n        auth_bearer=token,\n        headers={\"Accept\": \"application/vnd.github.v3+json\"},\n        timeout=30,\n    )\n\ndef get_user_repos(client: httpr.Client, username: str) -&gt; list:\n    \"\"\"Get repositories for a GitHub user.\"\"\"\n    response = client.get(\n        f\"https://api.github.com/users/{username}/repos\",\n        params={\"per_page\": 10, \"sort\": \"updated\"}\n    )\n\n    if response.status_code == 200:\n        return response.json()\n    elif response.status_code == 401:\n        raise ValueError(\"Invalid or expired token\")\n    else:\n        raise Exception(f\"API error: {response.status_code}\")\n\n# Usage\nif __name__ == \"__main__\":\n    client = create_api_client()\n    repos = get_user_repos(client, \"thomasht86\")\n    for repo in repos:\n        print(f\"- {repo['name']}: {repo['description']}\")\n</code></pre>"},{"location":"tutorial/authentication/#next-steps","title":"Next Steps","text":"<ul> <li>Async Client - Make concurrent authenticated requests</li> <li>SSL/TLS - Client certificate authentication (mTLS)</li> </ul>"},{"location":"tutorial/making-requests/","title":"Making Requests","text":"<p>This guide covers everything you need to know about making HTTP requests with httpr.</p>"},{"location":"tutorial/making-requests/#http-methods","title":"HTTP Methods","text":"<p>httpr supports all standard HTTP methods:</p> <pre><code>import httpr\n\nclient = httpr.Client()\n\n# GET - Retrieve data\nresponse = client.get(\"https://httpbin.org/get\")\n\n# POST - Create/submit data\nresponse = client.post(\"https://httpbin.org/post\", json={\"key\": \"value\"})\n\n# PUT - Update/replace data\nresponse = client.put(\"https://httpbin.org/put\", json={\"key\": \"value\"})\n\n# PATCH - Partial update\nresponse = client.patch(\"https://httpbin.org/patch\", json={\"key\": \"value\"})\n\n# DELETE - Remove data\nresponse = client.delete(\"https://httpbin.org/delete\")\n\n# HEAD - Get headers only (no body)\nresponse = client.head(\"https://httpbin.org/get\")\n\n# OPTIONS - Get supported methods\nresponse = client.options(\"https://httpbin.org/get\")\n</code></pre> <p>You can also use the generic <code>request()</code> method:</p> <pre><code>import httpr\n\nclient = httpr.Client()\nresponse = client.request(\"GET\", \"https://httpbin.org/get\")\nresponse = client.request(\"POST\", \"https://httpbin.org/post\", json={\"key\": \"value\"})\n</code></pre>"},{"location":"tutorial/making-requests/#query-parameters","title":"Query Parameters","text":"<p>Add query parameters to the URL using the <code>params</code> argument:</p> <pre><code>import httpr\n\n# Using params dict\nresponse = httpr.get(\n    \"https://httpbin.org/get\",\n    params={\"search\": \"python\", \"page\": 1, \"limit\": 10}\n)\n\n# Result: https://httpbin.org/get?search=python&amp;page=1&amp;limit=10\nprint(response.json()[\"args\"])\n# {\"search\": \"python\", \"page\": \"1\", \"limit\": \"10\"}\n</code></pre> <p>Automatic String Conversion</p> <p>All parameter values are automatically converted to strings. Numbers, booleans, and other types work seamlessly.</p>"},{"location":"tutorial/making-requests/#default-parameters","title":"Default Parameters","text":"<p>Set default query parameters on the client that are included in every request:</p> <pre><code>import httpr\n\n# API key included in all requests\nclient = httpr.Client(params={\"api_key\": \"your-api-key\"})\n\nresponse = client.get(\"https://api.example.com/users\")\n# URL: https://api.example.com/users?api_key=your-api-key\n\nresponse = client.get(\"https://api.example.com/posts\", params={\"page\": 1})\n# URL: https://api.example.com/posts?api_key=your-api-key&amp;page=1\n</code></pre>"},{"location":"tutorial/making-requests/#request-headers","title":"Request Headers","text":"<p>Set custom headers for individual requests or as client defaults:</p>"},{"location":"tutorial/making-requests/#per-request-headers","title":"Per-Request Headers","text":"<pre><code>import httpr\n\nresponse = httpr.get(\n    \"https://httpbin.org/headers\",\n    headers={\n        \"X-Custom-Header\": \"my-value\",\n        \"Accept\": \"application/json\",\n        \"User-Agent\": \"my-app/1.0\"\n    }\n)\n</code></pre>"},{"location":"tutorial/making-requests/#default-headers","title":"Default Headers","text":"<p>Set headers that are sent with every request:</p> <pre><code>import httpr\n\nclient = httpr.Client(\n    headers={\n        \"Authorization\": \"Bearer token123\",\n        \"Accept\": \"application/json\"\n    }\n)\n\n# All requests include these headers\nresponse = client.get(\"https://api.example.com/data\")\n</code></pre>"},{"location":"tutorial/making-requests/#modifying-client-headers","title":"Modifying Client Headers","text":"<p>Update headers after client creation:</p> <pre><code>import httpr\n\nclient = httpr.Client()\n\n# Set new headers\nclient.headers = {\"X-Api-Key\": \"secret\"}\n\n# Read current headers\nprint(client.headers)  # {\"x-api-key\": \"secret\"}\n</code></pre> <p>Header Case</p> <p>Headers are stored in lowercase internally (HTTP/2 requirement) but can be accessed case-insensitively.</p>"},{"location":"tutorial/making-requests/#request-body","title":"Request Body","text":"<p>httpr supports multiple ways to send data in the request body. These options are mutually exclusive - use only one per request.</p>"},{"location":"tutorial/making-requests/#json-data","title":"JSON Data","text":"<p>The most common way to send structured data:</p> <pre><code>import httpr\n\nresponse = httpr.post(\n    \"https://httpbin.org/post\",\n    json={\n        \"name\": \"John Doe\",\n        \"email\": \"john@example.com\",\n        \"tags\": [\"python\", \"rust\"],\n        \"metadata\": {\"version\": 1}\n    }\n)\n\n# Content-Type is automatically set to application/json\nprint(response.json()[\"json\"])\n</code></pre>"},{"location":"tutorial/making-requests/#cbor-data-transparent","title":"CBOR Data (Transparent)","text":"<p>CBOR (Concise Binary Object Representation) encoding is automatically used when you set the <code>Accept: application/cbor</code> header:</p> <pre><code>import httpr\n\n# Simply add Accept header - serialization happens transparently\nresponse = httpr.post(\n    \"https://api.example.com/data\",\n    json={  # Use json parameter as normal\n        \"name\": \"John Doe\",\n        \"values\": [1, 2, 3, 4, 5],\n        \"metadata\": {\"version\": 1}\n    },\n    headers={\"Accept\": \"application/cbor\"}  # Triggers CBOR serialization\n)\n\n# Content-Type is automatically set to application/cbor\n# Server receives CBOR-encoded data\n</code></pre> <p>CBOR offers several advantages over JSON:</p> <ul> <li>Smaller size: Binary encoding is more compact than text</li> <li>Faster processing: No text parsing overhead</li> <li>Better for binary data: Native support for byte arrays</li> <li>Type preservation: Maintains exact numeric types</li> </ul> <p>Use CBOR when:</p> <ul> <li>Working with large arrays or datasets</li> <li>Building high-performance APIs</li> <li>Developing IoT or embedded applications</li> <li>Reducing bandwidth usage is critical</li> </ul> <p>Note</p> <p>The server must support CBOR requests. Check the API documentation to confirm CBOR is accepted.</p>"},{"location":"tutorial/making-requests/#form-data","title":"Form Data","text":"<p>Send URL-encoded form data:</p> <pre><code>import httpr\n\nresponse = httpr.post(\n    \"https://httpbin.org/post\",\n    data={\n        \"username\": \"john\",\n        \"password\": \"secret\",\n        \"remember\": \"true\"\n    }\n)\n\n# Content-Type: application/x-www-form-urlencoded\nprint(response.json()[\"form\"])\n# {\"username\": \"john\", \"password\": \"secret\", \"remember\": \"true\"}\n</code></pre>"},{"location":"tutorial/making-requests/#binary-data","title":"Binary Data","text":"<p>Send raw bytes directly:</p> <pre><code>import httpr\n\n# Send raw bytes\nresponse = httpr.post(\n    \"https://httpbin.org/post\",\n    content=b\"raw binary data\"\n)\n\n# Send string as bytes\nresponse = httpr.post(\n    \"https://httpbin.org/post\",\n    content=\"text data\".encode(\"utf-8\")\n)\n</code></pre>"},{"location":"tutorial/making-requests/#file-uploads","title":"File Uploads","text":"<p>Upload files using multipart/form-data:</p> <pre><code>import httpr\n\nresponse = httpr.post(\n    \"https://httpbin.org/post\",\n    files={\n        \"document\": \"/path/to/document.pdf\",\n        \"image\": \"/path/to/photo.jpg\"\n    }\n)\n</code></pre> <p>The <code>files</code> dictionary maps form field names to file paths. Files are read and uploaded automatically.</p> <p>File Paths</p> <p>The <code>files</code> argument expects file paths as strings, not file objects. The files must exist on disk.</p>"},{"location":"tutorial/making-requests/#timeouts","title":"Timeouts","text":"<p>Control how long to wait for responses:</p>"},{"location":"tutorial/making-requests/#request-timeout","title":"Request Timeout","text":"<pre><code>import httpr\n\n# Wait up to 10 seconds for this request\nresponse = httpr.get(\"https://httpbin.org/delay/2\", timeout=10)\n</code></pre>"},{"location":"tutorial/making-requests/#client-default-timeout","title":"Client Default Timeout","text":"<pre><code>import httpr\n\n# Default timeout for all requests\nclient = httpr.Client(timeout=30)\n\n# Uses 30 second timeout\nresponse = client.get(\"https://httpbin.org/get\")\n\n# Override for specific request\nresponse = client.get(\"https://httpbin.org/delay/5\", timeout=60)\n</code></pre>"},{"location":"tutorial/making-requests/#timeout-behavior","title":"Timeout Behavior","text":"<ul> <li>Default timeout is 30 seconds</li> <li>Timeout of <code>0</code> or very small values may cause immediate timeout</li> <li>If the server doesn't respond within the timeout, an exception is raised</li> </ul> <pre><code>import httpr\n\ntry:\n    response = httpr.get(\"https://httpbin.org/delay/10\", timeout=1)\nexcept Exception as e:\n    print(f\"Request timed out: {e}\")\n</code></pre>"},{"location":"tutorial/making-requests/#redirects","title":"Redirects","text":"<p>By default, httpr follows HTTP redirects automatically:</p> <pre><code>import httpr\n\n# Follows up to 20 redirects by default\nresponse = httpr.get(\"https://httpbin.org/redirect/3\")\nprint(response.url)  # Final URL after redirects\n</code></pre>"},{"location":"tutorial/making-requests/#configuring-redirects","title":"Configuring Redirects","text":"<pre><code>import httpr\n\n# Disable redirects\nclient = httpr.Client(follow_redirects=False)\nresponse = client.get(\"https://httpbin.org/redirect/1\")\nprint(response.status_code)  # 302\n\n# Limit number of redirects\nclient = httpr.Client(max_redirects=5)\n</code></pre>"},{"location":"tutorial/making-requests/#protocol-options","title":"Protocol Options","text":""},{"location":"tutorial/making-requests/#https-only","title":"HTTPS Only","text":"<p>Restrict to secure connections only:</p> <pre><code>import httpr\n\nclient = httpr.Client(https_only=True)\n\n# Works\nresponse = client.get(\"https://example.com\")\n\n# Fails - HTTP not allowed\n# response = client.get(\"http://example.com\")\n</code></pre>"},{"location":"tutorial/making-requests/#http2","title":"HTTP/2","text":"<p>Enable HTTP/2 only mode:</p> <pre><code>import httpr\n\n# Use only HTTP/2\nclient = httpr.Client(http2_only=True)\nresponse = client.get(\"https://example.com\")\n</code></pre> <p>Note</p> <p>When <code>http2_only=False</code> (default), httpr uses HTTP/1.1. Set to <code>True</code> for HTTP/2.</p>"},{"location":"tutorial/making-requests/#complete-example","title":"Complete Example","text":"<p>Here's a complete example showing various request options:</p> <pre><code>import httpr\n\n# Create a configured client\nclient = httpr.Client(\n    headers={\"User-Agent\": \"my-app/1.0\"},\n    params={\"api_version\": \"v2\"},\n    timeout=30,\n    follow_redirects=True,\n    max_redirects=10,\n)\n\n# GET request with query params\nresponse = client.get(\n    \"https://httpbin.org/get\",\n    params={\"search\": \"python\"},\n    headers={\"Accept\": \"application/json\"}\n)\nprint(f\"Status: {response.status_code}\")\nprint(f\"URL: {response.url}\")\n\n# POST with JSON\nresponse = client.post(\n    \"https://httpbin.org/post\",\n    json={\"message\": \"Hello, World!\"},\n    timeout=60  # Override timeout for this request\n)\nprint(response.json())\n\n# Cleanup\nclient.close()\n</code></pre>"},{"location":"tutorial/making-requests/#next-steps","title":"Next Steps","text":"<ul> <li>Response Handling - Learn to work with response data</li> <li>Authentication - Add authentication to your requests</li> </ul>"},{"location":"tutorial/response-handling/","title":"Response Handling","text":"<p>This guide covers how to work with HTTP responses in httpr.</p>"},{"location":"tutorial/response-handling/#the-response-object","title":"The Response Object","text":"<p>Every request returns a <code>Response</code> object with all the information about the server's response:</p> <pre><code>import httpr\n\nresponse = httpr.get(\"https://httpbin.org/get\")\n\n# Access response data\nprint(response.status_code)  # HTTP status code\nprint(response.text)         # Body as string\nprint(response.content)      # Body as bytes\nprint(response.headers)      # Response headers\nprint(response.cookies)      # Response cookies\nprint(response.url)          # Final URL (after redirects)\nprint(response.encoding)     # Character encoding\n</code></pre>"},{"location":"tutorial/response-handling/#status-codes","title":"Status Codes","text":"<p>Check the HTTP status code to determine if the request succeeded:</p> <pre><code>import httpr\n\nresponse = httpr.get(\"https://httpbin.org/status/200\")\nprint(response.status_code)  # 200\n\nresponse = httpr.get(\"https://httpbin.org/status/404\")\nprint(response.status_code)  # 404\n\n# Check for success (2xx status codes)\nif 200 &lt;= response.status_code &lt; 300:\n    print(\"Success!\")\nelif 400 &lt;= response.status_code &lt; 500:\n    print(\"Client error\")\nelif 500 &lt;= response.status_code &lt; 600:\n    print(\"Server error\")\n</code></pre>"},{"location":"tutorial/response-handling/#response-body","title":"Response Body","text":""},{"location":"tutorial/response-handling/#text-content","title":"Text Content","text":"<p>Get the response body as a decoded string:</p> <pre><code>import httpr\n\nresponse = httpr.get(\"https://httpbin.org/html\")\nprint(response.text)  # HTML content as string\n</code></pre> <p>The encoding is automatically detected from:</p> <ol> <li>The <code>Content-Type</code> header charset</li> <li>HTML meta charset tag (first 2048 bytes)</li> <li>Falls back to UTF-8</li> </ol> <p>Access the detected encoding:</p> <pre><code>import httpr\n\nresponse = httpr.get(\"https://httpbin.org/encoding/utf8\")\nprint(response.encoding)  # \"utf-8\"\n</code></pre>"},{"location":"tutorial/response-handling/#binary-content","title":"Binary Content","text":"<p>Get the raw response body as bytes:</p> <pre><code>import httpr\n\nresponse = httpr.get(\"https://httpbin.org/bytes/100\")\nprint(type(response.content))  # &lt;class 'bytes'&gt;\nprint(len(response.content))   # 100\n\n# Useful for binary files\nresponse = httpr.get(\"https://httpbin.org/image/png\")\nwith open(\"image.png\", \"wb\") as f:\n    f.write(response.content)\n</code></pre>"},{"location":"tutorial/response-handling/#json-content","title":"JSON Content","text":"<p>Parse the response body as JSON:</p> <pre><code>import httpr\n\nresponse = httpr.get(\"https://httpbin.org/json\")\ndata = response.json()\n\nprint(type(data))  # &lt;class 'dict'&gt;\nprint(data[\"slideshow\"][\"title\"])\n</code></pre> <p>Note</p> <p><code>json()</code> is a method, not a property. Call it with parentheses.</p>"},{"location":"tutorial/response-handling/#cbor-content-transparent-deserialization","title":"CBOR Content (Transparent Deserialization)","text":"<p>When the server returns <code>Content-Type: application/cbor</code>, the <code>json()</code> method automatically deserializes CBOR data:</p> <pre><code>import httpr\n\n# Request CBOR data by setting Accept header\nresponse = httpr.get(\n    \"https://api.example.com/data\",\n    headers={\"Accept\": \"application/cbor\"}\n)\n\n# json() automatically detects and deserializes CBOR based on Content-Type\ndata = response.json()  # Works transparently with CBOR!\n\nprint(type(data))  # &lt;class 'dict'&gt; or &lt;class 'list'&gt;\nprint(data)\n</code></pre> <p>You can also explicitly use <code>cbor()</code> if you know the data is CBOR:</p> <pre><code>import httpr\n\nresponse = httpr.get(\"https://api.example.com/cbor-data\")\ndata = response.cbor()  # Explicitly deserialize as CBOR\n</code></pre> <p>CBOR is a binary serialization format that's more compact than JSON, making it ideal for:</p> <ul> <li>Large datasets: Smaller payload sizes compared to JSON</li> <li>IoT applications: Efficient data transfer for resource-constrained devices</li> <li>High-performance APIs: Faster serialization/deserialization</li> </ul> <p>Transparent Usage</p> <p>In most cases, you don't need to think about CBOR vs JSON. Just use <code>response.json()</code> and httpr will automatically handle the deserialization based on the Content-Type header.</p>"},{"location":"tutorial/response-handling/#html-conversion","title":"HTML Conversion","text":"<p>httpr provides built-in HTML-to-text conversion using Rust's <code>html2text</code> crate:</p> <pre><code>import httpr\n\nresponse = httpr.get(\"https://example.com\")\n\n# Convert HTML to Markdown\nmarkdown = response.text_markdown\nprint(markdown)\n\n# Convert HTML to plain text (no formatting)\nplain = response.text_plain\nprint(plain)\n\n# Convert HTML to rich text\nrich = response.text_rich\nprint(rich)\n</code></pre> <p>This is useful for:</p> <ul> <li>Extracting readable content from web pages</li> <li>Processing HTML for text analysis</li> <li>Creating plain-text versions of HTML emails</li> </ul>"},{"location":"tutorial/response-handling/#response-headers","title":"Response Headers","text":"<p>Access response headers through the <code>headers</code> attribute:</p> <pre><code>import httpr\n\nresponse = httpr.get(\"https://httpbin.org/response-headers?X-Custom=test\")\n\n# Headers are case-insensitive\nprint(response.headers[\"content-type\"])\nprint(response.headers[\"Content-Type\"])  # Same result\nprint(response.headers[\"CONTENT-TYPE\"])  # Also works\n\n# Check if header exists\nif \"x-custom\" in response.headers:\n    print(response.headers[\"x-custom\"])\n\n# Get with default value\nvalue = response.headers.get(\"x-missing\", \"default\")\n\n# Iterate over headers\nfor key, value in response.headers.items():\n    print(f\"{key}: {value}\")\n\n# Get all header names\nprint(list(response.headers.keys()))\n\n# Get all header values\nprint(list(response.headers.values()))\n</code></pre>"},{"location":"tutorial/response-handling/#common-headers","title":"Common Headers","text":"<pre><code>import httpr\n\nresponse = httpr.get(\"https://httpbin.org/get\")\n\n# Content information\ncontent_type = response.headers.get(\"content-type\")\ncontent_length = response.headers.get(\"content-length\")\n\n# Caching\ncache_control = response.headers.get(\"cache-control\")\netag = response.headers.get(\"etag\")\n\n# Server information\nserver = response.headers.get(\"server\")\ndate = response.headers.get(\"date\")\n</code></pre>"},{"location":"tutorial/response-handling/#response-cookies","title":"Response Cookies","text":"<p>Access cookies set by the server:</p> <pre><code>import httpr\n\nresponse = httpr.get(\"https://httpbin.org/cookies/set?session=abc123\")\n\n# Cookies as a dictionary\nprint(response.cookies)  # {\"session\": \"abc123\"}\n\n# Access specific cookie\nif \"session\" in response.cookies:\n    print(response.cookies[\"session\"])\n</code></pre>"},{"location":"tutorial/response-handling/#cookie-persistence","title":"Cookie Persistence","text":"<p>With <code>cookie_store=True</code> (default), cookies are automatically stored and sent with subsequent requests:</p> <pre><code>import httpr\n\nclient = httpr.Client(cookie_store=True)  # Default\n\n# First request sets a cookie\nclient.get(\"https://httpbin.org/cookies/set?token=xyz\")\n\n# Cookie is automatically included in next request\nresponse = client.get(\"https://httpbin.org/cookies\")\nprint(response.json()[\"cookies\"])  # {\"token\": \"xyz\"}\n</code></pre> <p>See the Cookie Handling guide for more details.</p>"},{"location":"tutorial/response-handling/#final-url","title":"Final URL","text":"<p>After redirects, check the final URL:</p> <pre><code>import httpr\n\nresponse = httpr.get(\"https://httpbin.org/redirect/3\")\n\n# The URL after following all redirects\nprint(response.url)  # https://httpbin.org/get\n</code></pre> <p>This is useful for:</p> <ul> <li>Detecting redirects</li> <li>Getting the canonical URL</li> <li>Debugging redirect chains</li> </ul>"},{"location":"tutorial/response-handling/#complete-example","title":"Complete Example","text":"<p>Here's a comprehensive example of response handling:</p> <pre><code>import httpr\n\ndef fetch_and_process(url: str) -&gt; dict:\n    \"\"\"Fetch a URL and return processed response data.\"\"\"\n\n    response = httpr.get(url, timeout=10)\n\n    result = {\n        \"url\": response.url,\n        \"status\": response.status_code,\n        \"success\": 200 &lt;= response.status_code &lt; 300,\n    }\n\n    # Get content type\n    content_type = response.headers.get(\"content-type\", \"\")\n    result[\"content_type\"] = content_type\n\n    # Process based on content type\n    if \"application/json\" in content_type:\n        result[\"data\"] = response.json()\n    elif \"text/html\" in content_type:\n        result[\"text\"] = response.text_markdown  # Convert HTML to markdown\n    else:\n        result[\"text\"] = response.text\n\n    # Include cookies if present\n    if response.cookies:\n        result[\"cookies\"] = response.cookies\n\n    return result\n\n\n# Usage\nresult = fetch_and_process(\"https://httpbin.org/json\")\nprint(f\"Status: {result['status']}\")\nprint(f\"Data: {result['data']}\")\n</code></pre>"},{"location":"tutorial/response-handling/#error-handling","title":"Error Handling","text":"<p>Handle potential errors when processing responses:</p> <pre><code>import httpr\n\ntry:\n    response = httpr.get(\"https://httpbin.org/status/500\")\n\n    if response.status_code &gt;= 400:\n        print(f\"HTTP Error: {response.status_code}\")\n    else:\n        data = response.json()\n\nexcept Exception as e:\n    print(f\"Request failed: {e}\")\n</code></pre>"},{"location":"tutorial/response-handling/#streaming-responses","title":"Streaming Responses","text":"<p>For large responses, you can stream the data instead of buffering it entirely in memory. This is useful for downloading large files, processing Server-Sent Events (SSE), or handling large API responses.</p>"},{"location":"tutorial/response-handling/#basic-streaming","title":"Basic Streaming","text":"<p>Use the <code>stream()</code> context manager to get a streaming response:</p> <pre><code>import httpr\n\nclient = httpr.Client()\n\n# Stream response bytes\nwith client.stream(\"GET\", \"https://httpbin.org/stream-bytes/10000\") as response:\n    print(f\"Status: {response.status_code}\")\n\n    for chunk in response.iter_bytes():\n        print(f\"Received {len(chunk)} bytes\")\n        # Process chunk without loading entire response in memory\n</code></pre>"},{"location":"tutorial/response-handling/#streaming-modes","title":"Streaming Modes","text":"<p>httpr provides three ways to iterate over streaming responses:</p>"},{"location":"tutorial/response-handling/#1-byte-chunks-iter_bytes","title":"1. Byte Chunks (<code>iter_bytes()</code>)","text":"<p>Iterate over raw bytes chunks:</p> <pre><code>with client.stream(\"GET\", \"https://httpbin.org/stream-bytes/1000\") as response:\n    for chunk in response.iter_bytes():\n        # chunk is bytes\n        process_binary_data(chunk)\n</code></pre> <p>Or use direct iteration (equivalent to <code>iter_bytes()</code>):</p> <pre><code>with client.stream(\"GET\", \"https://httpbin.org/stream-bytes/1000\") as response:\n    for chunk in response:  # Same as response.iter_bytes()\n        process_binary_data(chunk)\n</code></pre>"},{"location":"tutorial/response-handling/#2-text-chunks-iter_text","title":"2. Text Chunks (<code>iter_text()</code>)","text":"<p>Iterate over decoded text chunks:</p> <pre><code>with client.stream(\"GET\", \"https://httpbin.org/html\") as response:\n    for text_chunk in response.iter_text():\n        # text_chunk is str, decoded using response encoding\n        print(text_chunk, end=\"\")\n</code></pre> <p>The text is automatically decoded using the response's character encoding (from <code>Content-Type</code> header or detected from content).</p>"},{"location":"tutorial/response-handling/#3-line-by-line-iter_lines","title":"3. Line by Line (<code>iter_lines()</code>)","text":"<p>Iterate over the response line by line:</p> <pre><code>with client.stream(\"GET\", \"https://httpbin.org/stream/10\") as response:\n    for line in response.iter_lines():\n        # line is str\n        print(line.strip())\n</code></pre> <p>This is particularly useful for:</p> <ul> <li>Server-Sent Events (SSE): Process events as they arrive</li> <li>JSONL/NDJSON: Parse newline-delimited JSON</li> <li>Log streaming: Process log lines in real-time</li> </ul> <pre><code># Example: Processing Server-Sent Events\nwith client.stream(\"GET\", \"https://example.com/events\") as response:\n    for line in response.iter_lines():\n        if line.startswith(\"data:\"):\n            data = line[5:].strip()  # Remove \"data:\" prefix\n            process_event(data)\n</code></pre>"},{"location":"tutorial/response-handling/#conditional-reading","title":"Conditional Reading","text":"<p>You can check headers before deciding whether to read the body:</p> <pre><code>with client.stream(\"GET\", \"https://httpbin.org/get\") as response:\n    # Headers are available immediately\n    content_type = response.headers.get(\"content-type\")\n    content_length = response.headers.get(\"content-length\")\n\n    if response.status_code != 200:\n        print(f\"Error: {response.status_code}\")\n        return  # Don't read body\n\n    if content_length and int(content_length) &gt; 1_000_000:\n        print(\"File too large!\")\n        return  # Don't read body\n\n    # Only read if checks pass\n    for chunk in response.iter_bytes():\n        process(chunk)\n</code></pre>"},{"location":"tutorial/response-handling/#reading-all-at-once","title":"Reading All at Once","text":"<p>If you need to read the entire response after starting a stream:</p> <pre><code>with client.stream(\"GET\", \"https://httpbin.org/get\") as response:\n    # Check headers first\n    if response.status_code == 200:\n        # Read entire remaining response\n        content = response.read()\n        print(f\"Total size: {len(content)} bytes\")\n</code></pre>"},{"location":"tutorial/response-handling/#downloading-large-files","title":"Downloading Large Files","text":"<p>Streaming is ideal for downloading large files:</p> <pre><code>import httpr\n\nclient = httpr.Client()\n\nwith client.stream(\"GET\", \"https://example.com/large-file.zip\") as response:\n    if response.status_code == 200:\n        with open(\"large-file.zip\", \"wb\") as f:\n            for chunk in response.iter_bytes():\n                f.write(chunk)\n        print(\"Download complete!\")\n</code></pre> <p>With progress tracking:</p> <pre><code>with client.stream(\"GET\", \"https://example.com/large-file.zip\") as response:\n    total_size = int(response.headers.get(\"content-length\", 0))\n    downloaded = 0\n\n    with open(\"large-file.zip\", \"wb\") as f:\n        for chunk in response.iter_bytes():\n            f.write(chunk)\n            downloaded += len(chunk)\n            if total_size:\n                percent = (downloaded / total_size) * 100\n                print(f\"Downloaded: {percent:.1f}%\", end=\"\\r\")\n</code></pre>"},{"location":"tutorial/response-handling/#streaming-with-post","title":"Streaming with POST","text":"<p>Streaming works with all HTTP methods:</p> <pre><code>with client.stream(\n    \"POST\",\n    \"https://api.example.com/process\",\n    json={\"input\": \"data\"}\n) as response:\n    # Stream the API response\n    for line in response.iter_lines():\n        result = json.loads(line)\n        print(result)\n</code></pre>"},{"location":"tutorial/response-handling/#stream-state","title":"Stream State","text":"<p>The streaming response tracks its state:</p> <pre><code>with client.stream(\"GET\", \"https://httpbin.org/get\") as response:\n    print(response.is_closed)    # False\n    print(response.is_consumed)  # False\n\n    content = response.read()\n\n    print(response.is_consumed)  # True (after reading)\n\nprint(response.is_closed)  # True (after context manager exits)\n</code></pre>"},{"location":"tutorial/response-handling/#exception-handling","title":"Exception Handling","text":"<p>Streaming raises specific exceptions:</p> <pre><code>import httpr\n\ntry:\n    with client.stream(\"GET\", \"https://httpbin.org/get\") as response:\n        content = response.read()\n\n        # This will raise StreamConsumed\n        more = response.read()\n\nexcept httpr.StreamConsumed:\n    print(\"Cannot read stream twice\")\n\nexcept httpr.StreamClosed:\n    print(\"Stream was closed\")\n</code></pre>"},{"location":"tutorial/response-handling/#async-streaming","title":"Async Streaming","text":"<p>The <code>AsyncClient</code> also supports streaming with the same API:</p> <pre><code>import asyncio\nimport httpr\n\nasync def stream_data():\n    async with httpr.AsyncClient() as client:\n        async with client.stream(\"GET\", \"https://httpbin.org/stream-bytes/1000\") as response:\n            # Note: iteration is sync, but context manager is async\n            for chunk in response.iter_bytes():\n                process(chunk)\n\nasyncio.run(stream_data())\n</code></pre> <p>Note</p> <p>With <code>AsyncClient</code>, the context manager is async (<code>async with</code>), but the iteration over chunks remains synchronous (regular <code>for</code> loop, not <code>async for</code>).</p>"},{"location":"tutorial/response-handling/#important-notes","title":"Important Notes","text":"<ul> <li>Always use context manager: The <code>with</code> statement ensures proper cleanup</li> <li>Headers available immediately: You can check status, headers, and cookies before reading the body</li> <li>Cannot re-read: Once the stream is consumed, you cannot read it again</li> <li>Automatic cleanup: The stream is automatically closed when the context manager exits</li> </ul>"},{"location":"tutorial/response-handling/#next-steps","title":"Next Steps","text":"<ul> <li>Authentication - Add authentication to requests</li> <li>Async Client - Use async/await for concurrent requests</li> </ul>"},{"location":"writings/","title":"Blog","text":""},{"location":"writings/2025/02/25/lorem-ipsum-dolor-sit-amet/","title":"Lorem ipsum dolor sit amet","text":"<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Donec a diam lectus. Sed sit amet ipsum mauris. Maecenas congue ligula ac quam viverra nec consectetur ante hendrerit. Donec et mollis dolor. Praesent et diam eget libero egestas mattis sit amet vitae augue. Nam tincidunt est et ultrices eleifend, nunc risus varius orci, in dignissim purus enim quis turpis.</p>"},{"location":"writings/archive/2025/","title":"2025","text":""}]}